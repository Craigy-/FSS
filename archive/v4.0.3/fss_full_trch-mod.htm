<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Author" content="Craigy (grinder@tsu.tula.ru)" />
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=windows-1251" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8" />
<title>Система футбольной статистики (v4.0.3)</title>
<style type="text/css" media="screen">
html, body {
  height: 100%; }
body {
  position: relative;
  background: #F3F3F3;
  color: #333333;
  font: 11px Arial, Verdana, Helvetica, sans-serif;
  line-height: 130%; }
* {
  padding: 0;
  margin: 0; }
a, .blue {
  color: #436976; }
a img, table {
  border: 0; }
a:focus {
  outline: none; }
.z {
  border-spacing: 0;
  border-collapse: collapse; }
.z td {
  padding: 0; }
.bb {
  font-weight: bold; }
.m3 {
  margin-bottom: 3px; }
.m5 {
  margin-bottom: 5px; }
.m10 {
  margin-bottom: 10px; }
.m15 {
  margin-bottom: 15px; }
.m20 {
  margin-bottom: 20px; }
.m25 {
  margin-bottom: 25px; }
.m30 {
  margin-bottom: 30px; }
.m35 {
  margin-bottom: 35px; }
.s10 {
  font-size: 10px;
  line-height: 120%; }
.s11 {
  font-size: 11px;
  line-height: 120%; }
.s12 {
  font-size: 12px;
  line-height: 120%; }
.s13 {
  font-size: 13px;
  line-height: 120%; }
.s14 {
  font-size: 14px;
  line-height: 120%; }
.s15 {
  font-size: 15px;
  line-height: 120%; }
h1 {
  font-size: 24px;
  line-height: 120%;
  color: #434A4D;
  margin: 0 0 3px 0;
  white-space: nowrap; }
h2, h2 a {
  clear: both;
  font-size: 18px;
  line-height: 120%;
  color: #07A2E4;
  margin-top: 10px;
  padding: 2px 0 12px 15px;
  border-bottom: 2px solid #CCCCCC; }
h3 {
  font-size: 15px;
  line-height: 120%;
  color: #000000;
  padding: 0 0 5px 23px;
  margin: 0 5px 20px 0;
  background: url('data:image/gif;base64,R0lGODlhEAAPAMQAAP/abP/QYvTAWsHBweSxTbGxsd2pRaWlpXGu25+fn8+TJpeXl2egxcyRJGCZwV6Ts1mTvbqCHFKPvleNsIODg1CHrEqGtbB0DUmBqEN/sTx3qTt4rTRunGRkZC1nmP///yH5BAUUAB8ALAAAAAAQAA8AAAVw4CcmxUJR4vdMVfodw1J06cq4sEyn0y1yidhMEUlVHJAPx5PQEQiGYgUDQUg0mg+FFgkICBEqwpLZuEQNwDcyPp8VarDbNYWv3atp1S6v9ZBtfEUiPR9VFil2BhciLSISGS4KAQpuHFhnjGdLZnMiIQA7') no-repeat 0 1px;
  border-bottom: 1px solid #CCCCCC; }
#tt h3 {
  display: block!important;
  color: #2E5B89;
  padding: 0;
  margin: 10px 0;
  background: none;
  border: 0; }
#popup_data_save h3 {
  background: url('data:image/gif;base64,R0lGODlhEAAQANX/ACkplDExlDExnDk5nDk5pUJCnEpKnEpKpUpSrUpStVJSpVJSrVJStVpSrVparVpatVpavVpaxmNjzmtrznNztXN7vXt7nISEnISErYSEtYSExoyMrYyMtYyUxpSUrZSUxpycpZyctZyc1qWlvaWl1qWt1q2tzq2t1q2t3rW1zrW11r29zr293sbG58bOxsbOzs7Ozs7O587W59bW1tbW3tbW797e3t7e5+/v7+/v9+/39/f39/f3//f//8DAwP///yH5BAEAAD4ALAAAAAAQABAAQAarQJ8PkZrBjkjYzHQQVhgPDelUOpFIVZFk4askajiabTym4ViRRlcieWAGgxXu1wIEII7uFzfr+2dnaXo1PDmGhzk7aGoVbBAdHxkbIy0oBAQReY0TDxcjMTw9OykAApl6MoWIhjyLgzo3sbI3gYx7f361XQgxOzo7wMGKgo1sxhIREcYTjGwPHAYBIDN0dnhrbRYFFDc8PyoBAtc+DgsHHi4vLy4uIQUFCj5BADs=') no-repeat 0 1px; }
#popup_correct h3 {
  background: url('data:image/gif;base64,R0lGODlhEAAQANX/AAAAAACEACEAISlKWjk5SkJSWkpKSkpSWkpSc1JSWmMAY3Nzc3uEvXuUxoSEtYSUnJSUvZTO75ylxpzO75zW96WtxqXW962txq21zq211q3W77W1xrW91rW93rXG3rXG57XO77Xe973G1r3O773e98bGAMbGxsbe98bn987O587W587n99bn99bv/97v/+fv/+f3/+/3Ie/3//f3GPf3//f//8DAwP//AP//If///wAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADYALAAAAAAQABAAQAaeQJvtAyqCPkQOw6ZQCG2cHE3mYq0OtxJA5Hh+cqawmEXIAp6Vl/VE0kzekUlXOMrZ7zlVYwAInG0ddzQvVQlmF08YNWJhBgBhck8SLSgkIRoWExGbFHNDUzKhoSkNCAEBAkJfeDk1KQgxWk8eeIMuDzhaG09RjCYLM1oiEE8ZOTJqKygHAFsanhUwVignIQVvmp6TvoyRQg7g4eLhNkEAOw==') no-repeat 0 1px; }
label {
  padding-left: 5px;
  cursor: pointer; }
.left {
  float: left;
  margin: 0 15px 5px 0; }
.right {
  float: right;
  margin: 0 0 5px 15px; }
input, .btn, select, textarea {
  font-size: 11px;
  background: #FFFFFF;
  border: 1px solid #CCCCCC;
  padding: 3px 5px;
  color: #333333; }
.popup textarea {
  width: 670px;
  height: 110px;
  padding: 3px 0;
  background: #F3F3F3;
  border: 0; }
input, img.chk {
  padding: 4px 5px; }
input[type="checkbox"], select {
  padding: 0; }
input[disabled], .grey {
  color: #999999; }
.btn {
  display: inline-block;
  background: url('data:image/gif;base64,R0lGODlhAQAVALMAAP////39/fj4+PPz8+7u7ujp6eTj497f39nZ2dXV1M/PzszMzAAAAAAAAAAAAAAAACH5BAQUAP8ALAAAAAABABUAAAQLEMhJgRikmIOSWhEAOw==') repeat-x 0 100% #F3F3F3;
  padding: 4px 5px 4px 5px;
  cursor: pointer; }
.btn input {
  padding: 0;
  border: 0;
  background: none;
  cursor: pointer; }
a.btn {
  text-decoration: none; }
.chk {
  background: none;
  border: 0; }
.shl {
  color: #436976;
  font-weight: bold;
  font-style: italic; }
ol {
  padding: 0px;
  margin: 10px 0 25px 0; }
ol li {
  margin: 0 0 10px 15px;
  list-style-position: outside;
  list-style-type: decimal; }
.red, .red a {
  color: #8C0100; }
.hr {
  font-size: 1px;
  line-height: 1px;
  height: 1px;
  border-bottom: 1px dotted #CCCCCC; }

#container {
  min-width: 1008px;
  min-height: 100%;
  overflow: hidden; }
#header {
  position: relative;
  min-height: 85px;
  background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAsCAYAAACkJ9JhAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK8AAACvABQqw0mAAAACV0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVggMjAwNId2rM8AAAAtSURBVHicY/j27dt/JgYGBgYI8f//fwYkLjYxNO6/f/+IUozfFJzqiDUei5sBj+4uCG99pbUAAAAASUVORK5CYII=') repeat-x 0 100% #F6F6F6;
  border-bottom: 2px solid #CCCCCC;
  padding: 10px 0 0 15px; }
#body, .popup {
  background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAeCAYAAADtlXTHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK8AAACvABQqw0mAAAACV0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVggMjAwNId2rM8AAAAwSURBVHicY7h69ep/Jn5+fgYmBgYGKMHIyIjMQnCxyTIwMDAwMTExYdeB0yi8hgIAOYUEE8wmb3AAAAAASUVORK5CYII=') repeat-x 0 0 #F3F3F3; }
#first_start {
  padding: 30px 15px; }
#menu {
  float: left;
  width: 315px;
  background: url('data:image/gif;base64,R0lGODlhBQAFAKIAAPz8/Ozs7Onp6efn5+bm5uTk5MzMzAAAACH5BAQUAP8ALAAAAAAFAAUAAAMNaBFgJkA4MIYj2JVtEgA7') repeat-y 100% 0;
  padding: 20px 0 32767px 15px;
  margin-bottom: -32767px; }
#content {
  margin-left: 330px;
  padding: 15px 0 0 30px; }
.readonly #menu {
  width: 5px;
  padding-left: 0; }
.readonly #all {
  display: none; }
.readonly #content {
  margin-left: 5px;
  padding-left: 10px; }
.popup {
  border: 3px solid #999999;
  position: fixed;
  z-index: 9999;
  width: 680px;
  height: 280px;
  padding: 10px; }
#popup_correct {
  width: 480px;
  height: 248px; }

.text {
  float: left;
  width: 450px; }
.console {
  margin-left: 450px;
  padding: 5px 10px 0 0; }
#mmnu {
  position: absolute;
  bottom: 0;
  right: 0; }
#mmnu li {
  background: url('data:image/gif;base64,R0lGODlh9AE2ANUAAPf39/T3+fPz8/Hx8fHy8vDw8PDx8u/w8e/v7+7w8e3w8O3t7ent7unt7+rt7+rq6uTq7Ofn5+Xl5eDn6t3m6eDg4N/f39Lg5d3d3dPg5c7e49ra2tnZ2cra4NfX18na4NXV1cfY38bY3tTU1NPT09LS0sPW3cDV3MHV3L/U273T2s7Ozs3NzczMzLjP2LXO1rTN1rXN1gei5P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEHADMALAAAAAD0ATYAAAb/wJlwBrCAWsikcslsOp/QqHRKrVqv2Kx2y+16v+CweEzejiyAodrC4kQGgrh8Tq/b7/i8fs/v+/+AgYKDhIWGh4iJiouMjYIFER4sFmozICALjpqbnJ2en6ChoqOkpXgLl0MWJAimrq+wsbKztLW2dgUlFUQrmbe/wMHCw8TFmwsrABgbckhxzgLQxtPU1dbX2IkcGCAPzS3P4NHi2eXm5+jptRJHcOrv8PHy840L0vT4+fr78ywsc9Du8RtIsKBBU/cCkjvIsKHDh4MEQpxIsaLFbxczatxIMOFCjiBDijTmcaTJkyhnSUzJsqVLTitfypxJE1DMmjhz6ryps6dP/5Y8fwodujEo0aNIHRpNyrSpvqVOo0pNB3Wq1avUqmLdyvWW1q5gwyL8KLas2Vct1AS4gAKG27dw48qdS7eu3bt48+rdy7ev37+AAwseTLiw4cOIEysOfOJCgEpCLrz4MMHA2cuYFyWYEOLFhUooRDTITLo0IgcmTAy5kEKB6dewAx1QkWFGABcOYuverYeBiwAaOsiRISMOcePFeSsn/UEDCgjDkx8XMH25dbMUUMQgcL27bgcxYngfD/vFiznTq5NfjzU8eunJ2cuf6n6+fbD17+u/mp96/P0AEtWfegEW2FN/Bib4E4IKNogTgw5G+BKEElaIEoUWZhgShhp2mCIRhx6GOBGIIpbIEIkmpjgQiiq2iA+LLsYID4wy1nhODEEAADs=') no-repeat 0 0;
  float: left;
  height: 15px;
  padding: 7px 15px 5px 20px;
  list-style: none;
  cursor: pointer; }
#mmnu li.tab_act {
  background-position: 0 -27px;
  cursor: default; }
#mmnu li * {
  color: #436976;
  text-decoration: none; }
#mmnu li.tab_hover * {
  text-decoration: underline; }
#mmnu li.tab_act * {
  color: #07A2E4; }
.smnu {
  height: 28px;
  border-bottom: 1px solid #CCCCCC;
  margin-bottom: 15px; }
.smnu li {
  float: left;
  background: #FFFFFF;
  height: 9px;
  border: 1px solid #CCCCCC;
  margin: 0 5px 0 0;
  padding: 7px 20px 11px 20px;
  list-style: none;
  cursor: pointer; }
.smnu li.tab_act {
  border: 1px solid #9AA9B6;
  background: #C6D9EC;
  cursor: default; }
.smnu li * {
  font-size: 12px;
  color: #436976;
  text-decoration: none; }
.smnu li.tab_act * {
  font-weight: normal;
  color: #000000; }
.toggler, .open {
  float: right;
  width: 5px;
  height: 9px;
  cursor: pointer;
  background: url('data:image/gif;base64,R0lGODlhCgAJAIAAALS0tP///yH5BAUUAAEALAAAAAAKAAkAAAIRjANwm7nYnIkR0mbpua8+uBQAOw==') no-repeat 0 0; }
.open {
  background-position: -5px 0; }
.inner_els {
  padding-right: 15px; }
.inner_els h3 {
  display: none; }
.block {
  float: left;
  width: 199px;
  height: 60px;
  white-space: nowrap;
  margin: 0 6px 0 0; }
.instr {
  font-style: italic;
  height: 25px; }
.pages, .print {
  float: left;
  padding-right: 30px; }
.pages * {
  margin-right: 7px; }
.print {
  background: url('data:image/gif;base64,R0lGODlhEAAQANX/ACEYISEhGDExMTk5OUJCQlJSUmNjY2tra3Nzc4SEhIyMjIyMlJSUlJSUnJSt95ycnJyczpyt95yt/6WlpaWlraWlxqWtpaW9/6XWpa2tra2tta3G/7W1tb29vb29xr3Gvb3G573O/8bGxsbO587Ozs7O1s7W3s7e/9bW1tbn/97e3t7n7+fn5+fn7+fn/+/v7+/v9/f398DAwP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADIALAAAAAAQABAAQAaeQJkQQoREIsJk8kEiqUQczKdCmXA8E6UMcgptLhKtbPF4zVqih4KRMAwCAISW670gxcIHivTooP4iGUkMGRMZIigvL08ZDwsMCloPDyUMAwUNiAlzKV1fd3hbnhcOoUIuJyAgIyYkDGJ9GRksMC8rexyvY4ckIiokFh0kgLkyDywsHRMaWAyPDQoHm3kPMTMoDwQAAAIGCZGwSQnfSUEAOw==') no-repeat 0 0;
  font-style: normal;
  padding: 0 0 6px 22px; }
.buttons {
  text-align: right; }
.bord {
  font-size: 12px;
  line-height: 130%;
  border-right: 1px solid #CCCCCC;
  border-bottom: 1px solid #CCCCCC; }
.bord th {
  background: #E9EDEF;
  border-left: 1px solid #CCCCCC;
  border-top: 1px solid #CCCCCC;
  text-align: left;
  padding: 7px; }
.bord th.c {
  text-align: center;
  width: 5%; }
.bord td {
  text-align: center;
  border-left: 1px solid #CCCCCC;
  border-top: 1px solid #CCCCCC;
  padding: 5px 7px 5px 7px; }
.bord td.l {
  text-align: left; }
.bord td.r {
  text-align: right; }
.bord td.nc {
  text-align: left;
  white-space: nowrap; }
td.lch, input#lch_text {
  background: #D5E2F0!important; }
td.le, input#le_text {
  background: #DAE0DC!important; }
td.out, input#out_text {
  background: #D8D8D8!important; }
.hl td {
  background: #ECECEC; }
.nofloat {
  overflow: hidden; }
.popup .btns {
  float: right;
  padding-right: 5px; }
.popup .btns .close {
  cursor: pointer;
  width: 10px;
  height: 10px;
  border: 1px solid #999999;
  background: url('data:image/gif;base64,R0lGODlhCAAIAIAAAJmZmf///yH5BAEHAAEALAAAAAAIAAgAAAIOBIJhi7zcYDTpUWiTAgUAOw==') no-repeat 1px 1px; }
</style>
<!--[if lte IE 7]><style type="text/css" media="screen">
h2 {
  margin: 0;
  padding: 12px 0 12px 15px;
  background: #FFFFFF; }
h3 {
  padding-left: 0; }
label {
  cursor: default; }
.btn {
  background: #FFFFFF;
  padding: 4px 0; }
#container {
  min-width: 1004px; }
* html #container {
  width: expression(((document.compatMode && document.compatMode=='CSS1Compat') ? document.documentElement.clientWidth : document.body.clientWidth) < 1010 ? "1004px" : "100%");
  overflow: visible; }
#header {
  background: #F3F3F3; }
* html #header {
  height: 95px;
  he\ight: 85px; }
.popup {
  position: absolute; }
.popup textarea {
  height: 109px; }
#menu {
  border-right: 2px solid #CCCCCC; }
* html #menu {
  border: 0;
  padding: 15px 0 0 15px;
  margin: 0; }
* html #all {
  position: relative;
  padding: 20px 10px;
  border: 2px solid #CCCCCC; }
* html .smnu li {
  padding: 7px 20px 8px 20px;
  border-bottom: 0; }
* html .smnu li.tab_act {
  border-bottom: 0; }
a.btn {
  padding: 4px 5px 5px 5px; }
#trn .nofloat .left {
  padding-bottom: 5px; }
* html .block {
  width: 222px; }
.instr {
  margin: -5px 0 5px 0; }
.print {
  padding-left: 0; }
.buttons {
  margin-top: 5px; }
.nofloat {
  zoom: 1; }
* html .ieFix {
  margin-left: -3px; }
</style><![endif]-->
<style type="text/css" media="print">
body {
  font: 14px Arial, Verdana, Helvetica, sans-serif;
  line-height: 130%; }
* {
  padding: 0;
  margin: 0; }
.z {
  border-spacing: 0;
  border-collapse: collapse; }
.z td {
  padding: 0; }
.bb {
  font-weight: bold; }
h2, h2 a {
  clear: both;
  font-size: 18px;
  line-height: 120%;
  margin-top: 10px;
  padding: 2px 0 12px 0; }
h3 {
  background: none;
  border: 0; }
.inner_els h3 {
  display: block;
  margin-bottom: 20px; }
#tt h3 {
  font-size: 15px;
  line-height: 120%;
  padding: 0;
  margin: 20px 0 10px 0; }

#container {
  margin: 0 1px;
  width: 99%; }
#tt, #bt {
  margin-top: 1px; }
#header, #menu, .smnu, .print, .buttons {
  display: none; }
#content {
  padding-top: 15px; }
.inner_els {
  page-break-after: always;
  display: block!important; }

.pages {
  text-align: right;
  padding: 5px 4px 0 0; }
.bord {
  font-size: 14px;
  line-height: 130%;
  border-right: 1px solid #CCCCCC;
  border-bottom: 1px solid #CCCCCC; }
.bord th {
  border-left: 1px solid #CCCCCC;
  border-top: 1px solid #CCCCCC;
  text-align: left;
  padding: 7px; }
.bord th.c {
  text-align: center;
  width: 5%; }
.bord td {
  text-align: center;
  border-left: 1px solid #CCCCCC;
  border-top: 1px solid #CCCCCC;
  padding: 5px 7px 5px 7px; }
.bord td.l {
  text-align: left; }
.bord td.r {
  text-align: right; }
.bord td.nc {
  text-align: left;
  white-space: nowrap; }
</style>
<link rel="icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAGABoAwAAFgAAACgAAAAQAAAAIAAAAAEAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZmZlmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbMzMz////MzMyZmZlmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbMzMz////////////19fW2trZzc3NmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbMzMz////////////////////19fWZmZlmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbMzMz////////////////////////////MzMxzc3NmZmZmZmZmZmZmZmZmZmZmZmbMzMz///////////////+8vLzMzMyrq6v////b29tzc3NmZmZmZmZmZmZmZmZmZmbMzMz///////+rq6sfHx9aWlqZmZk+Pj47OzuoqKjv7+96enpmZmZmZmZmZmZmZmbMzMz////b29szMzMnJyf///////////8zMzMfHx/U1NTb29tzc3NmZmZmZmZmZmbMzMz///96enqrq6v////v7++ZmZnv7+////+rq6tzc3P///+8vLxmZmZmZmZmZmbMzMz///9zc3P////v7+8zMzMAAAAzMzPv7+////9zc3P///////+MjIxmZmZmZmbMzMz///9mZmb////v7+8nJycAAAAnJyfv7+////9mZmb////////b29tmZmZmZmbMzMz///9aWlpmZmb///+2trYfHx+2trb///9mZmZMTEz///////////+MjIxmZmbMzMz///+rq6taWlr///////////////////9aWlqZmZn////////////FxcVmZmbMzMz////////b29vU1NSoqKh6enqZmZnMzMzU1NT////////////////19fVmZmbMzMz////////////v7++rq6snJyeZmZnv7+////////////////////////+CgoLMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMyZmZkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" type="image/x-icon" />
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAGABoAwAAFgAAACgAAAAQAAAAIAAAAAEAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZmZlmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbMzMz////MzMyZmZlmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbMzMz////////////19fW2trZzc3NmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbMzMz////////////////////19fWZmZlmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbMzMz////////////////////////////MzMxzc3NmZmZmZmZmZmZmZmZmZmZmZmbMzMz///////////////+8vLzMzMyrq6v////b29tzc3NmZmZmZmZmZmZmZmZmZmbMzMz///////+rq6sfHx9aWlqZmZk+Pj47OzuoqKjv7+96enpmZmZmZmZmZmZmZmbMzMz////b29szMzMnJyf///////////8zMzMfHx/U1NTb29tzc3NmZmZmZmZmZmbMzMz///96enqrq6v////v7++ZmZnv7+////+rq6tzc3P///+8vLxmZmZmZmZmZmbMzMz///9zc3P////v7+8zMzMAAAAzMzPv7+////9zc3P///////+MjIxmZmZmZmbMzMz///9mZmb////v7+8nJycAAAAnJyfv7+////9mZmb////////b29tmZmZmZmbMzMz///9aWlpmZmb///+2trYfHx+2trb///9mZmZMTEz///////////+MjIxmZmbMzMz///+rq6taWlr///////////////////9aWlqZmZn////////////FxcVmZmbMzMz////////b29vU1NSoqKh6enqZmZnMzMzU1NT////////////////19fVmZmbMzMz////////////v7++rq6snJyeZmZnv7+////////////////////////+CgoLMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMyZmZkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" type="image/x-icon" />
<script type="text/javascript">
// Яваскриптовый фреймворк
// Версия: 1.0.40 Final (20.05.2011)
// Авторы: Иван Азарёнок, Григорий Зарубин, Андрей Сидоров (Shogo.Ru)

//<![CDATA[
var suilib = {

  version: 'lite-1.0.40',

  collector: {events:[], elements:[], cache:{}},

  anonymous: function(){},

  client: {
    domSupported:  !!document.getElementById,
    nativeWrapper: !!window.HTMLElement,

    opera:    !!window.opera,
    msie:     !!(document.all && document.all.item && !window.opera && !window.postMessage),
    trident:  !!(document.all && document.all.item && !window.opera),
    safari:   !!(navigator.appVersion && navigator.appVersion.toLowerCase().indexOf('applewebkit') >= 0),
    gecko:    !!(window.Components && window.controllers),
    netscape: !!document.layers
  },

  debug: {
    info: window.console && console.firebug ? window.console.info : this.anonymous,
    error: window.console && console.firebug ? window.console.error : this.anonymous,
    log: window.console && console.firebug ? window.console.log : this.anonymous,
    warn: window.console && console.firebug ? window.console.warn : this.anonymous
  },

  ready: function(method, context, args) {
    if(!this.init.initialize) this.init.initialize = []
    this.init.initialize.push({method:(method || suilib.anonymous), context:(context || window), args:(args || [])})
  },

  init: function() {
    if(suilib.init.done) return null
    suilib.init.done = true
    suilib.body = (!!document.body ? document.body : document.getElementsByTagName('body')[0])
    if(window.addEventListener)
      window.addEventListener('click', suilib.clickCapture, true);
    else
      suilib.clickCapture.$('click', window, document);
    if(arguments.callee.initialize && arguments.callee.initialize.length)
      for(var i=0,l=arguments.callee.initialize.length; i<l; i++)
        arguments.callee.initialize[i].method.
        apply(arguments.callee.initialize[i].context, arguments.callee.initialize[i].args)
  },

  body: {},

  capturedClick: {},

  clickCapture: function(e) {
    suilib.capturedClick = e
  },

  extensions: {
    Array: {
      hasa: function(val) {
        if(this.indexOf) {
          var i = this.indexOf(val)
          return i==-1 ? false : i
        }
        for(var i=0; i<this.length; i++)
          if(this[i]===val) return i
        return false
      },
      walkwith: function(cb) {
        var ret = []
        for(var i=0; i<this.length; i++)
          ret.push(cb(this[i]))
        return ret
      },
      filter: function() {
        var flatten = []
        for(var i=0,l=arguments.length; i<l; i++)
          flatten.push(arguments[i])
        return suilib.domExt.filter.apply(this, flatten)
      },
      hash: function() {
        var result = {}
        for(var i=0,l=this.length; i<l; i++)
          result[i] = this[i]
        return result
      },
      tweener: function(obj, options) {
        return suilib.domExt.tweener.call(this, obj && options ? obj : null, !options ? obj : options)
      }
    },
    String: {
      trim: String.prototype.trim ?
        function() {
          return this==null ? '' : String.prototype.trim.call(this)
        } :
        function() {
          return this==null ? '' : this.toString().replace(/^\s+/, '').replace(/\s+$/, '')
      },
      camelize: function() {
        var parts = this.split('-'), len = parts.length
        if(len == 1) return parts[0];
        var c = this.charAt(0) == '-' ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1) : parts[0]
        for(var i=1; i<len; i++) c += parts[i].charAt(0).toUpperCase() + parts[i].substring(1)
        return c.toString()
      },
      find: function(what) {
        return (this.indexOf(what)>=0 ? true : false)
      },
      parseJSON: function() {
        var data = this.trim()

        if(window.JSON && window.JSON.parse) return window.JSON.parse(data)
        if(/^[\],:{}\s]*$/.test(data.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                                    .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                                    .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
          return (new Function('return ' + data))()
        }

        suilib.debug.error('Invalid JSON: ' + data)
      }
    },
    Date: {
      isLeapYear: function() {
        var year = this.getFullYear()
        return ((((year%4==0) && (year%100!=0)) || (year%400==0)) ? true : false)
      }
    },
    Function: {
      $: function() {
        var e = arguments[0], g = suilib.client.gecko
        for(var i=1,l=arguments.length; i < l; i++) {
          if(!arguments[i]) continue
          try {
            if(typeof arguments[i]=='object' && 'length' in arguments[i] && 'hasa' in arguments[i]) {
              var clone = []
              arguments[i].walkwith(function(el) { clone.push(el) })
              clone.unshift(e)
              this.$.apply(this, clone)
              continue
            }
            arguments[i] = $(arguments[i]); if(!arguments[i]) continue
            if(arguments[i].attachEvent) arguments[i].attachEvent('on'+e, this)
            else arguments[i].addEventListener(e, this, false)
            if(e!='unload') suilib.collector.events.push([this, e, arguments[i]]);
          } catch(ext) { suilib.debug.error('$\n'+ext) }
        }
        return this
      },
      $$: function() {
        var e = arguments[0], g = suilib.client.gecko
        for(var i=1,l=arguments.length; i < l; i++) {
          if(!arguments[i]) continue
          try {
            if(typeof arguments[i]=='object' && 'length' in arguments[i] && 'hasa' in arguments[i]) {
              var clone = []
              arguments[i].walkwith(function(el) { clone.push(el) })
              clone.unshift(e)
              this.$$.apply(this, clone)
              continue
            }
            arguments[i] = $(arguments[i]); if(!arguments[i]) continue
            if(arguments[i].detachEvent) arguments[i].detachEvent('on'+e, this)
            else arguments[i].removeEventListener(e, this, false)
          } catch(ext) { suilib.debug.error('$$\n'+ext) }
        }
        return this
      }
    }
  },

  domExt: {
    __e__: true,
    $: function() {
      var e = arguments[0]
      for(var i=1,l=arguments.length; i < l; i++)
        if(arguments[i] && arguments[i].$)
          arguments[i].$(e, this)
      return this
    },
    $$: function() {
      var e = arguments[0]
      for(var i=1,l=arguments.length; i < l; i++)
        if(arguments[i] && arguments[i].$$)
          arguments[i].$$(e, this)
      return this
    },
    filter: function(tag, cls, attr, deep) {
      var result = []; result.filter = suilib.extensions.Array.filter
      if(this instanceof Array) {
        for(var i=0,l=this.length; i<l; i++)
          if(this[i] && this[i].filter)
            result = result.concat(this[i].filter(tag, cls, attr, deep))
        return result
      }
      var list = (deep ? this.getElementsByTagName(tag || '*') : this.childNodes)
      outerLoop:
      for(var i=0,l=list.length; i<l; i++) {
        if(!list[i] || list[i].nodeType!=1) continue
        if(!deep && tag && tag!='*' && list[i].tagName.toLowerCase()!=tag.toLowerCase()) continue
        if(cls && list[i].className.split(' ').hasa(cls)===false) continue
        if(attr) for(var j in attr) try {
          if(list[i].getAttribute(j).toLowerCase()!==attr[j].toLowerCase()) continue outerLoop
        } catch(e) { continue outerLoop }
        result.push($(list[i]))
      }
      return result
    },
    unset: function(rmid) {
      if(rmid && this.removeAttribute) {
        var oid = this.getAttribute('id')
        if(suilib.collector.cache[oid]) delete(suilib.collector.cache[oid])
        this.removeAttribute('id')
      }
      this.parentNode.removeChild(this)
      return this
    },
    empty: function(deep, rmid) {
      while(this.firstChild) {
        if(deep && this.firstChild.nodeType==1) $(this.firstChild).empty(deep, rmid)
        if(rmid && this.firstChild.removeAttribute) {
          var oid = this.firstChild.getAttribute('id')
          if(suilib.collector.cache[oid]) delete(suilib.collector.cache[oid])
          this.firstChild.removeAttribute('id')
        }
        this.removeChild(this.firstChild)
      }
      return this
    },
    show: function(interval, args) {
      if(interval) {
        args = args.split(','); var params = {}
        for(var i=0,l=args.length; i<l; i++) switch(args[i].trim()) {
          case 'fade':
            params.opacity = [0, 100]
            this.setstyle('opacity:0')
          break
        }
        this.style.display = ''
        this.animate(interval, params)
      } else this.style.display = ''
      return this
    },
    hide: function(interval, args) {
      if(interval) {
        args = args.split(','); var params = {}, self = this
        for(var i=0,l=args.length; i<l; i++) switch(args[i].trim()) {
          case 'fade':
            params.opacity = [100, 0]
            this.setstyle('opacity:100')
          break
        }
        this.animate(interval, params, function() {
          self.hide(); self.setstyle('opacity:100') })
      } else this.style.display = 'none'
      return this
    },
    toggle: function(node, interval, args) {
      if(!node) return false
      if(interval) {
        args = args.split(','); var params = {}, effect, self = this
        for(var i=0,l=args.length; i<l; i++) switch(args[i].trim()) {
          case 'fade':
            params.opacity = [100, 0]
            this.setstyle('opacity:100')
            effect = args[i].trim()
          break
        }
        this.animate(interval, params, function() {
          self.hide(); self.setstyle('opacity:100'); $(node).show(interval, effect) })
      } else {
        this.style.display = 'none'
        $(node).style.display = ''
      }
      return this
    },
    animate: function(interval, args, complete, aic) {
      var timer = 0, step = 0, self = this, icall = (aic || 100)
      var stepdelta = interval * 1000 / icall

      var convert = function(prop, val) {
        var result
        switch(prop.camelize().trim()) {
          case 'width': case 'height': case 'left': case 'top': case 'fontSize':
            result = val + 'px'
          break
          case 'color': case 'backgroundColor':
            result = '#'+suilib.Color.hsl2hex(val, 100, 100)
          break
          default:
            result = val
        }
        return result
      }
      var callback = function(args, step) {
        var fn = arguments.callee
        if(!fn.$queue)  fn.$queue  = {}
        if(!fn.$ignore) fn.$ignore = {}

        for(var a in args) if(!fn.$queue[a]) {
          fn.$queue[a] = false
          if(typeof args[a]=='function' && args[a].call) {
            this.setstyle(a+':'+args[a].call(fn, step, a))
            continue
          }
          if(!('$'+a in fn)) fn['$'+a] = args[a][0]
          var delta = (Math.max(args[a][0], args[a][1]) - Math.min(args[a][0], args[a][1])) / stepdelta
          if(!delta) delta = 1
          this.setstyle(a+':'+convert(a, fn['$'+a]))
          if(args[a][1] > args[a][0]) {
            fn['$'+a] += delta
            if(fn['$'+a] >= args[a][1]) {
              fn.$queue[a] = true
              this.setstyle(a+':'+convert(a, args[a][1]))
            }
          } else if(args[a][1] < args[a][0]) {
            fn['$'+a] -= delta
            if(fn['$'+a] <= args[a][1]) {
              fn.$queue[a] = true
              this.setstyle(a+':'+convert(a, args[a][1]))
            }
          } else {
            this.setstyle(a+':'+convert(a, args[a][0]))
            fn.$queue[a] = true
          }
        }

        var done = true; for(var i in fn.$queue) if(!fn.$ignore[i] && fn.$queue[i]!==true) done = false
        if(done) fn.stop()
      }
      callback.loop = function(mode, prop) {
         this.$ignore[prop] = !!mode
      }
      callback.stop = function() {
        clearInterval(timer); if(complete) complete()
      }
      if(this.$intervalid) clearInterval(this.$intervalid)
      this.$intervalid = timer = setInterval(function(){step++; callback.apply(self, [args, step])}, icall)
    },
    tweener: function(obj, options) {
      if('jTweener' in window) return $t(obj && typeof(obj)=='object' && options ? obj : this, !options ? obj : options); else {
        suilib.debug.warn('jTweener not included!');
        return {
          'tween'         : suilib.anonymous,
          'percent'       : suilib.anonymous,
          'stop'          : suilib.anonymous,
          'addOptions'    : suilib.anonymous,
          'clearOptions'  : suilib.anonymous,
          'removeOptions' : suilib.anonymous
        }
      }
    },
    setstyle: function(style) {
      var rules = style.split(';')
      for(var i=0,l=rules.length; i<l; i++) {
        var hash = rules[i].split(':')
        var prop = hash[0].camelize().trim()
        try { switch(prop) {
          case 'float':
            this.style['styleFloat'] = hash[1].trim()
            this.style['cssFloat']   = hash[1].trim()
          break
          case 'opacity':
            var op = parseInt(hash[1], 10)
            if(document.body.filters) {
              var alph = (this.filters['DXImageTransform.Microsoft.alpha'] || this.filters.alpha)
              if(alph) alph.opacity = op
              else this.style.filter += "progid:DXImageTransform.Microsoft.Alpha(opacity="+op+")"
            } else {
              var aop = op / 100
              this.style.opacity = aop;
              this.style.MozOpacity = aop;
              this.style.KhtmlOpacity = aop;
            }
          break
          default:
            this.style[prop] = hash[1].trim()
        } } catch(exc) {  }
      }
      return this
    },
    classAdd: function(cls) {
      if(cls && typeof cls==='string') {
        var classNames = (cls || '').split(/\s+/)

        if(this.nodeType===1) {
          if(!this.className) {
            this.className = cls
          } else {
            var className = ' ' + this.className + ' ', setClass = this.className
            for(var c=0,cl=classNames.length; c<cl; c++) {
              if(className.indexOf(' ' + classNames[c] + ' ')<0) setClass += ' ' + classNames[c]
            }
            this.className = setClass.trim()
          }
        }
      }
      return this
    },
    classReplace: function(clsNew, clsOld) {
      if(typeof clsOld=='object' && clsOld.length)
        for(var i=0,l=clsOld.length; i<l; i++) this.classRemove(clsOld[i])
      else this.classRemove(clsOld)
      this.classAdd(clsNew)
      return this
    },
    classRemove: function(cls) {
      if((cls && typeof cls==='string') || cls===undefined ) {
        var classNames = (cls || '').split(/\s+/)
        if(this.nodeType===1 && this.className) {
          if(cls) {
            var className = (' ' + this.className + ' ').replace(/[\n\t\r]/g, ' ')
            for(var c=0,cl=classNames.length; c<cl; c++) {
              className = className.replace(' ' + classNames[c] + ' ', ' ')
            }
            this.className = className.trim()
          } else this.className = ''
        }
      }
      return this
    },
    offset: function(d) {
      var x = this.offsetLeft,y = this.offsetTop
      if(this.offsetParent && d) {
        var pos = $(this.offsetParent).offset(d)
        x += pos[0]; y += pos[1]
      }
      return [x,y]
    },
    html: function(html) {
      if(html && html.length && html.length===parseInt(html.length, 10))
        this.innerHTML = html
      return this.innerHTML
    },
    add: function(e, a, c) {
      var child = $(document.createElement(e))
      if(a) for(var p in a) {
        switch(p) {
          case 'class': child.classAdd(a[p]); break
          case 'style': child.setstyle(a[p]); break
          case 'innerHTML': child.html(a[p]); break
          default: child.setAttribute(p, a[p])
        }
      }
      if(c) for(var i=0,l=c.length; i<l; i++) if(c[i]) child.appendChild(c[i])
      if(this && this!=window && this!=document && this.appendChild) this.appendChild(child)
      return child
    },
    addtext: function(t) {
      var child = document.createTextNode(t)
      if(this && this!=window && this!=document && this.appendChild) this.appendChild(child)
      return child
    }
  },

  addProps: function(d, s, p) {
    for(var p in s)
      if(d[p] && p) continue
      else d[p] = s[p]
    return d
  },

  ajax: function(url, params, method, handler) {
    if(!url) url = document.location.protocol + '//' + document.location.hostname +
                   document.location.pathname + document.location.search
    handler  = (handler || suilib.anonymous)
    var pick = function() {
      var v  = [
        function(){return new XMLHttpRequest()},
        function(){return new ActiveXObject("Msxml2.XMLHTTP")},
        function(){return new ActiveXObject("Msxml3.XMLHTTP")},
        function(){return new ActiveXObject("Microsoft.XMLHTTP")}
      ], result
      for(var i=0,l=v.length; i<l; i++) {
        try { result = v[i]()
        } catch(exc) { continue }
        break
      }
      return result
    }
    var provider = pick()
    var xmlhttp  = provider
    var closure  = function() {
      handler({readyState: xmlhttp.readyState,
               statusCode:(xmlhttp.readyState==4) ? xmlhttp.status : null,
               responseJS:(xmlhttp.readyState==4 && xmlhttp.status==200) ?
                          (function(x){return x.responseText.parseJSON()})(xmlhttp) : null
               })
      if(xmlhttp.readyState==4) xmlhttp = null
    }
    if(!!params.hasa) params = params.join('&')
    if(method=='get') url += (url.match(/\?/) ? '&' : '?') + params
    url += (url.match(/\?/) ? '&' : '?') + '$js=' + ((new Date()).getTime())
    try {
      provider.open(method, url.toLowerCase(), true)
      provider.onreadystatechange = closure
      provider.setRequestHeader('X-Requested-With', 'Shogo UI/'+suilib.version)
      if(method=='post') provider.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')
      provider.setRequestHeader('Accept', 'text/javascript, text/html, application/xml, text/xml, */*')
      provider.setRequestHeader('Connection', 'close')
      provider.send(method=='post'?params:null)
    } catch(exc) {suilib.debug.error(exc+' '+params)}
    return provider
  },

  get: function(params, handler) {
    return this.ajax(null, params, 'get', handler)
  },

  post: function(params, handler) {
    return this.ajax(null, params, 'post', handler)
  },

  switchWait: function(mode, loader) {
    try { // это для ебучего ie6
      var ie = suilib.client.trident, szs = ie ? suilib.screensizes() : [];
      if(!arguments.callee.floatMover) arguments.callee.floatMover = function(e) {
        var scrlX  = document.documentElement.scrollLeft + document.body.scrollLeft;
        var scrlY  = document.documentElement.scrollTop  + document.body.scrollTop;
        floatloader.style.left = parseInt(e.pageX ? e.pageX : e.x+scrlX, 10) - 16 + 'px';
        floatloader.style.top  = parseInt(e.pageY ? e.pageY : e.y+scrlY, 10) - 15 + 'px';
      }

      var ipath   = 'i/ajax/',
          loaders = [ ipath + 'loader.gif', ipath + 'ajax.' + (ie ? 'gif' : 'png')];
      if(mode) {
        if(loader && loaders[loader]) {
          var floatloader = new Image();
          floatloader.src = loaders[loader];
          suilib.body.appendChild(floatloader);
          $(floatloader).setstyle('position:absolute; z-index:200');
          var evt = (window.event || suilib.capturedClick);
          try { if(evt.type!='click') evt = (ie ? window.event : suilib.capturedClick) } catch(e) {}
          var scrlX  = document.documentElement.scrollLeft + document.body.scrollLeft;
          var scrlY  = document.documentElement.scrollTop  + document.body.scrollTop;
          if(evt) {
            var sl = parseInt(evt.pageX ? evt.pageX : evt.x+scrlX, 10) - 16;
            var st = parseInt(evt.pageY ? evt.pageY : evt.y+scrlY, 10) - 15;
            szs[2] = ie ? szs[2] : Math.max(document.body.scrollWidth, window.innerWidth);
            szs[3] = ie ? szs[3] : Math.max(document.body.scrollHeight, window.innerHeight);
            if(isNaN(sl)) sl = Math.ceil(szs[2]/2) - 16;
            if(isNaN(st)) st = Math.ceil(szs[3]/2) - 16;
            $(floatloader).setstyle('top:' + st + 'px; left:' + sl + 'px');
          }
          if(!arguments.callee.floatloader) arguments.callee.floatloader = floatloader;
          arguments.callee.floatMover.$('mousemove', window, document);
        } else if(loader) { // невидимый запрос
        } else { // дефолтный статусбар
          if(!arguments.callee.wdiv)
            arguments.callee.wdiv = $(suilib.body).add('div', {'style' : 'position:' + (ie ? 'absolute' : 'fixed') + '; left:0; top:0; z-index:9998; margin:0; background:#000000; width:' + (ie ? szs[0]+'px' : '100%') + '; height:' + (ie ? szs[3]+'px' : '100%')});
            arguments.callee.wdiv.setstyle('opacity:30');
          if(!arguments.callee.idiv)
            arguments.callee.idiv = $(suilib.body).add('div', {'style' : 'position:' + (ie ? 'absolute' : 'fixed') + '; z-index:9999; text-align:center; padding-top:20%; color:#EBEBEB; width:100%; left:0; top:' + (ie ? (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop)+'px' : '0')}, [
              addtext('Пожалуйста, подождите...'),
              add('br'),
              add('img', {'src' : loaders[0]})
            ]);
        }
      } else {
        if(loader && loaders[loader]) {
          arguments.callee.floatMover.$$('mousemove', window, document);
          try { suilib.body.removeChild(arguments.callee.floatloader) } catch(e) {}
          arguments.callee.floatMover = null; arguments.callee.floatloader = null;
        } else if(loader) { // невидимый запрос
        } else { // дефолтный статусбар
          $(arguments.callee.wdiv).unset(true);
          $(arguments.callee.idiv).unset(true);
          arguments.callee.wdiv = null; arguments.callee.idiv = null;
          window.scrollBy(1,1);
          window.scrollBy(-1,-1);
        }
      }
    } catch(err) {}
  },

  screensizes: function() {
    var wW = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0;
    var wH = window.innerHeight ||  document.documentElement.clientHeight || document.body.clientHeight || 0;

    return [wW, wH, Math.min(document.body.scrollWidth, wW), Math.max(document.body.scrollHeight, wH)];
  },

  free: function() {
    for(var i=0; i<this.length; i++) {
      if(!this[i][0] || !this[i][0].$$ || !this[i][1] || !this[i][2]) continue
      this[i][0].$$(this[i][1], this[i][2]); this[i][0] = this[i][2] = this[i] = null
    }
  }
}

;(function(h){for(var n in h)   suilib.addProps(window[n].prototype, h[n])})(suilib.extensions)
if(suilib.client.nativeWrapper) suilib.addProps(window.HTMLElement.prototype, suilib.domExt)
var add = suilib.domExt.add, addtext = suilib.domExt.addtext, __e__ = true

function $() {
  if(!arguments[0]) return null
  var r = []
  if(arguments.length > 1)
    for(var i=0,l=arguments.length; i < l; i++)
      r.push($(arguments[i]))
  else switch(typeof arguments[0]) {
    case 'string': try {
      r = suilib.collector.cache[arguments[0]] ? suilib.collector.cache[arguments[0]] : document.getElementById(arguments[0])
      suilib.collector.cache[arguments[0]] = r } catch (e) { suilib.debug.error('[wrong node]:\n'+e) }
    break
    default:
      r = arguments[0]
  } try {
  if(arguments.length==1 && !r.__e__) r = suilib.addProps(r, suilib.domExt, true)
  } catch(e) { suilib.debug.error('[extend error]: '+arguments[0]+'\n'+e) } return r
}

;(function() {
  if(document.addEventListener) document.addEventListener('DOMContentLoaded', function() {
    document.removeEventListener('DOMContentLoaded', arguments.callee, false)
    suilib.init()
  }, false)
  if(document.attachEvent) {
    document.attachEvent('onreadystatechange', function() {
      if(document.readyState==='complete') {
        document.detachEvent('onreadystatechange', arguments.callee)
        suilib.init()
      }
    })
    if(document.documentElement.doScroll && window==window.top) (function() {
      if(suilib.init.done) return;
      try {
        document.documentElement.doScroll('left');
      } catch(e) {
        setTimeout(arguments.callee, 0)
        return
      }
      suilib.init()
    })()
  }
  window.onload = suilib.init
  ;(function() {
    suilib.free.call(suilib.collector.events)
    with(suilib.collector)
      for(var i=0; i<cache.length; i++)
        cache[i] = null
  }).$('unload', window)
})();

suilib.Color = {
  rgb2hex: function(rgb) {
    var x = '0123456789ABCDEF', s = rgb.split(','), hex = ''
    for(var i=0; i<3; i++) {
      var n  = parseInt(s[i], 10)
      hex += x.charAt(n >> 4) + x.charAt(n & 15)
    }
    return hex
  },

  hex2rgb: function(hex) {
    var x = '0123456789ABCDEF', c = []
    hex = hex.toUpperCase()
    for(var i=0; i<6; i+=2) c.push(16 * x.indexOf(hex.charAt(i)) + x.indexOf(hex.charAt(i+1)))
    c = c.join(', '); return c
  },

  hsl2rgb: function(hue, sat, lum) {
    var R, G, B, nH, nS, nL, nF, nP, nQ, nT, lH
    var lim = function(val, l, h) {
      if(val < l) val = l; if(val > h) val = h
      return val
    }
    if(sat > 0) {
      nH = hue / 60; nL = lum / 100; nS = sat / 100;
      lH = parseInt(nH, 10); nF = nH - lH
      nP = nL * (1 - nS); nQ = nL * (1 - nS * nF); nT = nL * (1 - nS * (1 - nF))
      switch (lH) {
        case 0:
          R = nL * 255; G = nT * 255; B = nP * 255
        break
        case 1:
          R = nQ * 255; G = nL * 255; B = nP * 255
        break
        case 2:
          R = nP * 255; G = nL * 255; B = nT * 255
        break
        case 3:
          R = nP * 255; G = nQ * 255; B = nL * 255
        break
        case 4:
          R = nT * 255; G = nP * 255; B = nL * 255
        break
        case 5:
          R = nL * 255; G = nP * 255; B = nQ * 255
        break
      }
    } else {
      R = (lum * 255) / 100; G = R; B = R
    }
    return parseInt(lim(R, 0, 255), 10)+', '+parseInt(lim(G, 0, 255), 10)+', '+parseInt(lim(B, 0, 255), 10)
  },

  hsl2hex: function(hue, sat, lum) {
    return this.rgb2hex(this.hsl2rgb(hue, sat, lum))
  }
};
//]]>
</script>
</head>

<body>

<div id="container">
  <div id="header">
    <div class="text">
      <h1>Система футбольной статистики</h1>
      <div class="desc">Football Statistics System (v4.0.3)</div>
    </div>

    <div class="console"><span class="red">Полностью обособленная динамическая система сбора футбольной статистики в одном файле.</span> Не требует никакого дополнительного софта, кроме браузера (с включенным javascript). <span id="admin">Все данные в определенном виде необходимо сохранять самостоятельно простым копи-пастом ;-)</span></div>

    <ul id="mmnu"><li></li></ul>
  </div>

  <h2 id="hdr"></h2>

  <div id="body">

    <div id="first_start" style="display:none;">
      <p class="m20">Это первый запуск приложения. Для начала работы Вам необходимо создать хотя бы один турнир и заполнить его командами. Вы можете создать несколько различных турниров с любым количеством групп и команд в каждом.<br />Для каждой команды можно указать один или несколько статусов, показывающих её заслуги по итогам прошлого сезона, а также назвать и выделить цветом три зоны в турнирной таблице.</p>

      <form id="trn" action="">
        <div class="m15"><b>Название турнира:</b>&nbsp;&nbsp;<input type="text" size="100" id="trn_name" />&nbsp;&nbsp;<span class="btn"><input type="button" value="Сохранить турнир" id="trn_save" /></span> <span class="btn"><input type="button" value="Очистить поля" id="trn_reset" /></span></div>
        <div class="nofloat m35">
          <div class="left"><b>Число групп:</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type="text" size="2" id="groups_num" value="1" />&nbsp;&nbsp;<b>по</b>&nbsp;&nbsp;<input type="text" size="2" id="commands_num_0" />&nbsp;&nbsp;<b>команд</b>&nbsp;&nbsp;&nbsp;&nbsp;<span class="btn"><input type="button" value="Добавить" id="groups_add" /></span></div>
          <div class="nofloat" style="padding:7px 0 0 20px;">
            <div class="m10"><input type="checkbox" class="chk" checked="checked" id="trn_results" /><label for="trn_results">сохранять результаты</label></div>
            По&nbsp;&nbsp;<select id="trn_ratio"><option value="2">2 матча&nbsp;&nbsp;</option><option value="1">1 матчу&nbsp;&nbsp;</option></select>&nbsp;&nbsp;проводят команды на всех стадиях турнира
          </div>
        </div>

        <div id="groups"></div>

        <div class="hr m20" style="clear:both;">&nbsp;</div>
        <div align="center"><span class="btn"><input type="button" value="Запустить систему" id="sys_load" /></span>&nbsp;&nbsp;<span class="btn"><input type="button" value="Сбросить все данные" id="data_reset" /></span></div>
      </form>
    </div>

    <div id="main" style="display:none;">
      <div id="menu">
        <div class="toggler" id="toggler" title="Скрыть/раскрыть блок ввода данных"></div>

        <div id="all">
          <h3>Ввод данных</h3>

          <div id="group_div"></div>

          <div id="input_tour_div"></div>

          <div class="m5"><span id="com_home_span"></span><input type="text" size="30" value="" id="com_home_inp" style="display:none;" /></div>
          <div class="m5"><input type="text" size="2" maxlength="2" value="0" id="count_home" />&nbsp;<b>:</b>&nbsp;<input type="text" size="2" maxlength="2" value="0" id="count_guest" />&nbsp;&nbsp;&nbsp;&nbsp;<span id="extra_ps_span" style="display:none;"><input type="checkbox" class="chk" id="extra_ps" /><label for="extra_ps">серия пенальти</label></span></div>
          <div class="m5" id="extra_ps_div" style="display:none;"><input type="text" size="2" maxlength="2" value="0" id="count_home_ps" />&nbsp;<b>:</b>&nbsp;<input type="text" size="2" maxlength="2" value="0" id="count_guest_ps" /></div>
          <div class="m15"><span id="com_guest_span"></span><input type="text" size="30" value="" id="com_guest_inp" style="display:none;" /></div>

          <div class="m5"><input type="checkbox" class="chk" id="tech" /><label for="tech">техническое поражение</label></div>

          <div id="extra_block">
            <div class="m20"><input type="checkbox" class="chk" id="extra" /><label for="extra">дополнительный матч</label></div>
            <div class="m10" id="extra_group_div" style="margin-top:-10px;overflow:hidden;height:0;">Cтадия:&nbsp;&nbsp;<span id="extra_group_span"></span><input type="text" size="30" value="" id="extra_group_inp" style="display:none;" /></div>
          </div>

          <div id="bombs_input"></div>

          <div class="m20">
            <div class="m3"><span class="btn"><input type="button" value="Добавить матч" id="match_add" /></span> <span class="btn"><input type="button" value="Скорректировать очки" id="correct_points" /></span></div>
            <span class="btn"><input type="button" value="Сохранить данные" id="data_save" /></span>
          </div>

          <div class="hr m10">&nbsp;</div>

          <p style="padding:0 40px 10px 0;">Выберите принимающую и гостевую команды и введите счет матча. В появившемся блоке появится возможность заполнить бомбардиров матча.<br /><span class="red">Учтите, что при каждой смене команды или счета блок ввода бомбардиров будет перестраиваться заново!</span></p>

          <div class="hr m10">&nbsp;</div>

          <div style="padding-right:40px;">
            <p>На конце фамилий игроков доступны следующие служебные символы:</p>
            <div class="nofloat">
              <div class="left"><b class="s15">*</b></div>
              <div class="nofloat">отмечает игрока, перешедшего в другой клуб внутри турнира (система автоматически корректирует статистику с учётом таких бомбардиров);</div>
            </div>
            <div class="nofloat">
              <div class="left"><b class="s15">-</b></div>
              <div class="nofloat">отмечает игрока, завершившего выступления в турнире (в блоке ввода такие бомбардиры будут недоступны).</div>
            </div>
            <p class="red">Внимание! Добавлять все эти метки необходимо вручную!</p>
          </div>
        </div>
      </div>

      <div id="content">
        <ul class="smnu">
        <li class="inner_hds"><b>Результаты</b></li>
        <li class="inner_hds"><b>Турнирная таблица</b></li>
        <li class="inner_hds"><b>Бомбардиры</b></li>
        </ul>

        <div class="inner_els">
          <h3>Результаты</h3>

          <div class="buttons m10"><b>Показать:</b> <span id="r_tours_span"></span><span id="r_types_span" style="display:none;">&nbsp;&nbsp;&nbsp;&nbsp;<b>Выводить по:</b> <select id="r_types"><option value="0">турам</option><option value="1">группам</option></select></span></div>
          <div id="rt"></div>
          <div class="instr">
            <div class="print"><a href="#" id="r_print">Распечатать статистику</a></div>
            <div class="buttons">Последняя редакция: <b></b></div>
          </div>
        </div>

        <div class="inner_els">
          <h3>Турнирная таблица</h3>

          <div id="tt"></div>
          <div class="instr">
            <div class="print"><a href="#" id="t_print">Распечатать статистику</a></div>
            <div class="buttons">Последняя редакция: <b></b></div>
          </div>
        </div>

        <div class="inner_els">
          <h3>Бомбардиры</h3>

          <div class="buttons m10"><b>Выводить по:</b> <select id="b_types"><option value="0">голам</option><option value="1">командам</option></select>&nbsp;&nbsp;&nbsp;&nbsp;<b>Сортировать игроков по:</b> <select id="b_sorts"><option value="0">фамилии</option><option value="1">командам</option><option value="2">голам</option></select></div>
          <div id="bt"></div>
          <div class="instr">
            <div class="pages"></div>
            <div class="buttons">Последняя редакция: <b></b></div>
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<div class="popup" id="popup_correct" style="display:none;">
  <div class="btns"><div id="correct_close" class="close"></div></div>
  <h3>Ручная коррекция очков</h3>
  <div class="m20">
    Эта функция позволяет как списать с одной из команд необходимое количество очков, так и их добавить: для этого просто выберите команду из списка, поставьте нужный знак (плюс или минус) и введите требуемое число. Затем нажмите кнопку <b>"Применить"</b>.<br />
    Данные в турнирной сетке обновятся динамически, но чтобы их сохранить - пожалуйста не забудьте нажать кнопку <b>"Сохранить данные"</b> в левом меню системы.
  </div>
  <div class="hr m10" style="clear:both;">&nbsp;</div>
  <div align="center" class="bb m10">Команда:&nbsp;&nbsp;<span id="correct_commands_span"></span></div>
  <div align="center" class="m20"><select id="correct_sign"><option value="-">&nbsp&mdash;&nbsp;&nbsp;</option><option value="+">&nbsp+&nbsp;&nbsp;</option></select> <input type="text" value="0" maxlength="2" size="2" id="correct_num" /></div>
  <div align="center"><span class="btn"><input type="button" value="Применить" id="correct_apply" /></span></div>
</div>

<div class="popup" id="popup_data_save" style="display:none;">
  <div class="btns"><div id="data_save_close" class="close"></div></div>
  <h3>Сохранение данных</h3>
  <div class="m10">Вставьте выделенную ниже строчку в самый низ исходного кода этой страницы между указанными комментариями, заменив ей уже существующую. Затем сохраните код и нажмите кнопку <b>"Обновить систему"</b>.</div>
  <p class="red">/* Все данные (начало вставки) */</p>
  <textarea id="data_save_text" cols="60" rows="6" readonly="readonly"></textarea>
  <p class="red m20">/* Все данные (конец вставки) */</p>
  <div align="center"><span class="btn"><input type="button" value="Обновить систему" id="data_save_refresh" /></span></div>
</div>

<script type="text/javascript">
//<![CDATA[
/*** Известные проблемы
  - картинки не отображаются в браузерах IE v6-7;
  - favicon глючит в любых FireFox и отображается в IE v6-7 только, если страница была добавлена в "Избранное";
  - из-за багов Google Chrome и некоторых версий Opera, вывод отсортированных данных (например, в таблицах
    бомбардиров или селекторе выбора туров) и многие другие важные функции системы работают неправильно;
  - в любых Safari и Chrome окно "Сохранение данных" не закрывается при нажатии на ESC.
***/


/*** История версий
v4.0.3 (09.09.11):
  Убрал из псевдонавигации group: нелогично, что в урле сохранялся один из параметров ввода данных (при этом выбранная группа
  для удобства сохраняется вплоть до перезагрузки страницы).
  Пофиксены баги:
    - при турнире с разным числом команд в группах:
      - в селекторах выбора туров теперь всегда выводится их максимум;
      - коррекция тура "на лету" при выборе несуществующего для текущей группы теперь также реализована и в селекторе переигровок;
    - из-за всех этих изменений пришлось переписать сохранение выбранных команд при смене тура переигровки.

v4.0.2 (29.08.11):
  Пофиксены баги:
   - при сортировке команд в турнирной таблице стали во всех пунктах учитываться технические поражения;
   - в подсветке команд в допстадиях не учитывалась "значимость" голов, забитых на чужом поле, при техническом поражении.

v4.0.1 (18.08.11):
  Исправлен серьёзный баг (по дурости занесённый в прошлой версии), из-за которого нельзя было добавить в допстадию больше одного матча.

v4.0 (23.06.11):
  Эта версия несовместима с предыдущими (немного изменён формат сохраняемых данных):
    - для их удобного портирования следует воспользоваться свежей версией утилиты concat.php.
  Добавлена поддержка "технических поражений":
    - такие матчи сохраняются обычным образом, но в них не существует бомбардиров, а в таблице результатов выводятся
      соответствующие пометки (при этом в выводе бомбардиров по командам корректно учитываются мячи, записанные засчёт
      "технических поражений");
    - режим реализован таким образом, что счёт этих матчей может быть любым, кроме ничейного (не обязательно 3:0);
    - возможен ввод как нового, так и перезапись старого матча (причём для любых стадий турнира);
    - при перезаписи матча в необходимых случаях вся общая статистика будет корректироваться "на лету", при этом:
      бомбардиры старого матча будут удалены, а полный текстовый результат сохранён для истории :)
  Дополнительные матчи:
    - теперь при добавлении матча, уже сохранённого в выбранной допстадии, старый результат будет перезаписан (режим переигровки),
      а статистика в необходимых случаях скорректирована;
    - исправлены баги в механизме сохранения бомбардиров для допстадий, раньше он правильно работал только при последовательном
      создании туров и стадий.
  Добавлена возможность ручной коррекции очков команд в турнирной сетке (идея hwg).
  Сортировка команд в турнирной таблице обновлена в соответствие с регламентом ЧР от 2010 года.
  Оптимизирован механизм открытия/закрытия модальных окон.
  Обновлена suilib. Дополнен и причёсан парсер объектов.
  Пофиксены баги:
    - смена тура переигровки больше не сбрасывает уже выбранные команды;
    - исправлена ошибка сортировки, из-за которой в некоторых случаях в заголовке неправильно выводилась текущая стадия;
    - слегка поправил автовыбор тура для переигровки.

v3.7 (24.02.11):
  Для удобства заполнения счёта матча сделана обработка фокусов для полей ввода.
  Доработка версии системы для печати.

v3.6.9 (18.02.11):
  Победитель матча при счёте 0:0 больше не подсвечивается (такая ситуация возможна, когда сыгран только один матч в парных этапах).

v3.6.8 (16.02.11):
  Починил когда-то сломанную возможность работы системы в режиме "только чтение" (параметр псевдонавигации admin=false).

v3.6.7 (25.01.11):
  Система падала из-за отсутствия проверки на наличие команд при создании турнира.

v3.6.6 (11.10.10):
  Исправлен баг, возникающий после добавления матча: во вкладке "Результаты" не всегда открывался тот тур, в котором этот матч был сыгран.

v3.6.5 (06.10.10):
  Пофиксены баги:
    - еще один вариант логики автовыбора тура в блоке ввода данных;
    - исправлен порядок вывода всех матчей с сортировкой по группам для мультигрупповых турниров.

v3.6.4 (14.09.10):
  Пофиксены баги:
    - при сохранении результатов служебные символы на конце имён бомбардиров удалялись не во всех браузерах;
    - переделана логика автовыбора тура в блоке ввода данных (всё равно не универсально, но лучше чем было ;-);
    - во вкладке "Результаты" стадии перед групповым этапом выводились в неверном порядке.

v3.6.3 (02.09.10):
  Пофиксены баги:
    - система падала при добавлении дополнительного матча с нулевой ничьей;
    - во вкладке "Результаты" не всегда правильно определялась стадия, открываемая по умолчанию.

v3.6.2 (01.09.10):
  Поправлен баг в блоке ввода: нельзя было добавить матч, если включена серия пенальти, а основной счёт матча не ничейный
  (раньше сделано было без учёта парных матчей).

v3.6.1 (01.09.10):
  Исправлен глобальный баг, из-за которого нельзя было создать турниры с количеством групп больше девяти и
  выбирать автора автогола, если голов забитых одной из команд также больше девяти.

v3.6 (31.08.10):
  Пофиксены баги:
    - служебные символы на конце имён бомбардиров больше не сохраняются в результатах;
    - некорректно работали сохранение и вывод авторов автоголов, забивавших их в составах разных команд.

v3.5 (27.08.10):
  Добавлен favicon (респект hwg за идею и картинку).
  Реализована поддержка служебных символов на конце имён бомбардиров (добавлять их необходимо вручную):
    - '*' отмечает игрока, перешедшего в другой клуб внутри турнира (система автоматически корректирует статистику с учётом таких бомбардиров);
    - '-' отмечает игрока, завершившего выступления в турнире (в блоке ввода такие бомбардиры будут недоступны).
  Практически полностью переписан вывод результатов:
    - показывать матчи для мультигрупповых турниров стало возможным как по турам, так и по группам;
    - добавлена поддержка объединённого вывода парных матчей в дополнительных стадиях турнира (идея hwg);
    - при переходах по чемпионатам теперь по умолчанию открывается последний тур или стадия хотя бы с одним добавленным матчем,
      если номер тура не был жёстко задан в урле при первоначальном открытии системы;
    - исправлены все баги и глюки в Safari.
  Доработки и багфиксы дополнительных матчей:
    - удалена опция "сохранять бомбардиров" из блока ввода (теперь бомбардиры всегда сохраняются в переигровках и в стадиях плей-офф
      и никогда - в стадиях перед группой);
    - любые действия в блоке серии пенальти больше не сбрасывают уже заполненные поля бомбардиров;
    - исправлена сортировка дополнительных матчей по стадиям;
    - отныне в результатах помечается матч, выигранный в дополнительное время (идея hwg);
    - команда, прошедшая в следующую стадию, теперь выделяется цветом;
    - исправлен подсчёт общего числа забитых мячей (в выводе бомбардиров по командам): теперь также учитываются голы стадии плей-офф.
  Обновлена suilib.
  Пофиксены баги:
    - теперь все вводимые данные проходят trim (удаление пробелов и всяких служебных символов в конце строки);
    - залатаны дыры в алгоритме парсинга параметров из урла, добавлена их автокоррекция, где ещё не было + исправлены возможные
      падения системы;
    - для полной кроссбраузерности были переписаны алгоритмы работы с селекторами;
    - исправлены глюки в выводе тура в заголовке.

v3.4 (16.06.10):
  Для мультигрупповых турниров в результатах матчей сделан вывод названий групп (идея hwg).
  Введён редактируемый при создании коэффициент количества матчей между командами в группах, определяющий общее число туров.
  Система теперь умеет работать в режиме "только чтение", позволяющем лишь просматривать статистику (параметр псевдонавигации admin=false).
  Пофиксены некоторые баги вёрстки.

v3.3 (20.05.10):
  Аварийный фикс парсера объектов: теперь можно смело пользоваться любыми кавычками.

v3.2 (31.03.10):
  Теперь во всех вкладках опционально могут отображаться эмблемы команд (идея hwg).

v3.1 (02.03.10):
  Доработка системы для работы с турнирами с разным числом команд в группах:
    - исправлен ряд серьёзных ошибок;
    - вместо сообщения об ошибке сделана коррекция "на лету" при выборе несуществующего тура для текущей группы в блоке "Ввод данных".
  Обновлена suilib. Дополнен парсер объектов.
  Пофиксены баги:
    - система падала, если в урле оказывался несуществующий номер группы;
    - из-за бага при первоначальном открытии системы не работал принудительный переход на нужную вкладку через параметр псевдонавигации.

v3.0 (16.02.10):
  Реализована возможность добавления дополнительных матчей (доступна только при включённом сохранении результатов):
    - такие матчи не входят в групповую турнирную сетку, их результаты доступны при просмотре отдельно, а авторы голов
      при необходимости могут быть сохранены в общую таблицу (но только для команд, которые там уже есть);
    - возможно добавление квалификационных матчей перед групповым этапом, стыковых, дополнительных или плей-офф матчей
      после него, а также переигровки матча любого тура (в этом случае вся общая статистика будет корректироваться "на лету");
    - добавлена возможность выбора уже сохранённой стадии (для объединения нескольких дополнительных матчей в одну логическую группу).
  Теперь система поддерживает создание турниров с несколькими группами (таких, как Лига чемпионов УЕФА):
    - при этом статистика результатов матчей, бомбардиров, а также дополнительных матчей остаётся общей;
    - количество команд в разных группах можно варьировать.
  Первый запуск:
    - добавлена поддержка создания турниров с несколькими группами;
    - переделан выбор подсветки мест в турнирной таблице (также добавлена возможность изменения названий зон подсветки);
    - улучшена система защиты от возможных ошибок.
  В сортировке команд теперь учитывается дополнительный матч между командами при абсолютном равенстве всех показателей.
  Модернизирована "защита от дурака", не дающая вводить неверные значения или выбирать неверные комбинации в блоке "Ввод данных".
  Псевдонавигация поддерживает сохранение группы из блока "Ввод данных".
  Для неактивных чекбоксов теперь красиво затеняется их подпись.
  Обновлена suilib. Дополнен парсер объектов.
  Пофиксены баги:
    - сохраняемые данные портились, если при создании турнира появлялась одна из ошибок ввода данных;
    - сортировка по голам, забитым на чужом поле во всех матчах, работала неверно (пункт 6);
    - система падала после добавления матча, если в нём были забиты мячи и не было ни одного автогола.

v2.0 (15.01.10):
  Реализованы сохранение и вывод результатов матчей в турах (включается опционально при создании турнира) (идея hwg):
    - при вводе матча теперь необходимо выбирать тур (для удобства сделан автовыбор);
    - добавлены поля для ввода минут матча, когда были забиты голы;
    - просмотр результатов возможен как для одного тура, так и для всех;
    - сделано автоопределение первого показываемого тура, если он не был задан при открытии в урле.
  Реализована полная сортировка по правилам распределения команд в турнирной таблице (с учётом всех пунктов регламента ЧР).
  Умный вывод ссылки для печати статистики и первоначальное автооткрытие рабочей вкладки.
  Багфиксы вёрстки, модернизирована и отлажена псевдонавигация.
  Окошко "Сохранение данных" теперь можно также закрывать нажатием клавишы ESC и кликом в пустое место экрана.
  Обновлена suilib. Фиксы функции заполнения селекторов и объекта "Динамические вкладки".

v1.9 (10.11.09):
  Реализована псевдонавигация, теперь можно обмениваться ссылками на нужную страничку в системе.
  Обновлена suilib, размеры экрана теперь возвращает её встроенный метод.
  Багфикс и дополнения парсера объектов, фиксы обработки смены сортировки бомбардиров и объекта "Динамические вкладки".

v1.8 (06.08.09):
  Доработка вывода тура, обновлена suilib.

v1.7 (20.07.09):
  Багфиксы вывода тура и парсера объектов.

v1.6 (15.07.09):
  Обновлена suilib.

v1.5 (13.07.09):
  Теперь в заголовке выводится прошедший/текущий тур. Обновлена suilib.

v1.4 (05.06.09):
  Добавлена возможность печати статистики, suilib обновлена до стабильного релиза.

v1.3 (27.03.09):
  Обновлена suilib.

v1.2 (25.03.09):
  Полная поддержка IE8.

v1.1 (18.03.09):
  Теперь авторы автоголов доступны в селекторе выбора бомбардиров.
  Переработан механизм удаления/объединения дубликатов (старый оказался глючным).

v1.0 (16.03.09):
  Первый стабильный релиз.
***/


/*** Cистема футбольной статистики ***/
var $key, $autogoals = [], $results = {}, $extra_names = {}, $isResults = false, $isGroups = false, $ratio = 0, $empty = true;
var $transitional_russian_champ_mod; // моды
var $total = [
  0,     // текущее количество игр в группе
  0,     // максимальное количество игр (отличается от первого для турниров с разным числом команд в группах)
  true,  // групповой этап стартовал? (обратное значение)
  false  // групповой этап сыгран?
];
var $url = {
  'champ'   : 1,
  'tab'     : false,
  'tour'    : [false, 0],
  'bombs'   : [0, 0],
  'admin'   : true,
  'backup'  : {
    'tab'   : false,
    'tour'  : false,
    'group' : 1
  }
};
var $alias = {
  'lch'   : 'Зона Лиги чемпионов УЕФА',
  'le'    : 'Зона Лиги Европы УЕФА',
  'out'   : 'Зона вылета',
  'champ' : [
            'Действующий чемпион',
            'data:image/gif;base64,R0lGODlhDgANANUAAPnu0ffuzPjsyPXpuPPov/jos/PnvfPnt/flrPbipPDjqvDiqe7bnPLciPTac/bVdvPVYOjUf/HNaPLLM//LAPPHOP/KAP/JAP3HA/bHFPTIG//HAP/GAP/FAP/EAPTEHvLFEv/BAP3CAP3AAPvBAP3BAPK+EPO9B/K7APS6APe5APC4AP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEHACwALAAAAAAOAA0AAAZSQJZwOAgMj0iTBMlkjVTN46HTYR4Aw4nF0hgKDAqUZ+y5mM8rghAiOp9JCWZmQ99ooiC3o3kIUSgYFCUHTBUcH0InHAVMKQhHDytIDAtMEYQsQQA7'
            ],
  'cup'   : [
            'Действующий обладатель Кубка',
            'data:image/gif;base64,R0lGODlhEAAMANUAAP3vqv/ts//krv/boP/Zkf/gAP3WZP/XUv/ZJv/QhuvVgOnTfv/YAP/WEf3TOOrRcf/RI//UAOnPcefOcv/OFufNZufMav/OCebLWufKYubJXv/JAPXLBuTGVeTGTu/FJP/AK//BEebDRebBQv+8HeO/Rt++Q+2/Bf26AOC6LeS5Jv2yAPe1AN62JuO4CumyIeWxHu+uBOCtJeOqB/6cAP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEHADUALAAAAAAQAAwAAAZrwJpQaNGURpjKUNgRqgChjTQSQcGEnlHJkgpQKAlCo7B5WUajhaSmMIBIAwFkQ3vUHvaW8HOIQBBkMUJ6QiV3DhdUESsYNSZLNSUZHhwMDCyShpBLJ4Kbnxgjn58PGaObeKdDEykuMzITkEEAOw=='
            ],
  'new'   : [
            'Новичок лиги',
            'data:image/gif;base64,R0lGODlhDQAMAIAAAIwBAP///yH5BAEHAAEALAAAAAANAAwAAAIXjA+nCr3c3It00ftCzEjyzWleBn7jdBYAOw=='
            ]
};

/* Смена заголовка */
function makeHeader(text) {
  $('hdr').html('Панель статистики :: ' + text);
}

/* Возвращает минимальное число в массиве */
function getMin(arr) {
  return Math.min.apply(Math, arr);
}

/* Возвращает максимальное число в массиве */
function getMax(arr) {
  return Math.max.apply(Math, arr);
}

/* Текущее время в нужном формате */
function currentTime() {
  var all = new Date();
  return ((all.getDate() < 10) ? '0' : '') + all.getDate() + '.' + ((all.getMonth() < 9) ? '0' : '') + (parseInt(all.getMonth(), 10) + 1) + '.' + all.getFullYear().toString().substr(2) + ' ' + all.getHours() + ((all.getMinutes() < 10) ? ':0' : ':') + all.getMinutes();
}

/* Добавляет в урл параметры для псевдонавигации по системе или считывает их текущее значение в глобальный хэш $url

  champ  - глобальное переключение между турнирами (верхнее меню), по умолчанию - 1
  tab(1) - опционально, по умолчанию открывается вкладка "Результаты", если они были включены
           (комбинации tour - [x,0], [x,1], где x - любое число от 1 до последнего тура, либо -100 для показа всех туров, либо (<-1 || >последний тур) для дополнительных стадий, по умолчанию - максимальный тур или стадия, содержащие хотя бы один матч)
      2  - Турнирная таблица
      3  - Бомбардиры
           (комбинации bombs - [0,1], [1,1], [1,2], [0,0] по умолчанию)
  admin  - включение/выключение режима 'read only' (по умолчанию - true, режим выключен)
*/
function navi(mode) {
  // Парсим урл и заполняем глобальный хэш $url
  if(!mode) {
    var pars = document.location.hash.split(/\&/);
    pars.walkwith(function(el) {
      if(el) {
        var ta = el.split(/\=/);
        switch(ta[0]) {
          case 'tab':
            $url.tab = parseInt(ta[1], 10); break;
          case 'tour':
            $url.tour = ta[1].parseJSON(); break;
          case 'bombs':
            $url.bombs = ta[1].parseJSON(); break;
          case 'admin':
            $url.admin = ta[1].parseJSON(); break;
          default:
            $url.champ = parseInt(ta[1], 10);
        }
      }
    });

    // Бэкапим первоначальные значения некоторых параметров
    $url.backup.tab = $url.tab;
    $url.backup.tour = $url.tour[0];
  }

  // Меняем урл на основе глобального хэша
  else
    document.location.hash = '#champ=' + $url.champ + '&tab=' + $url.tab + '&tour=' + objTools.parse($url.tour) + '&bombs=' + objTools.parse($url.bombs) + '&admin=' + $url.admin;
}

/* Добавляет массив опций в селектор */
function addOption(sid, attr) {
  if(attr && attr.length)
  for(var i=0,l=attr.length; i<l; i++) {
    var opt = new Option();
    for(var j in attr[i]) {
      switch(j) {
      case 'innerHTML':
        $(opt).html(attr[i][j]); break;
      case 'selected':
        opt.selected = opt.defaultSelected = attr[i][j]; break;
      case 'disabled':
        opt.disabled = attr[i][j]; break;
      case 'value':
      default:
        opt.setAttribute(j, attr[i][j]);
      }
    }
    $(sid).appendChild(opt);
  }
}

/* Возвращает value или innerHTML выбранной опции селектора */
function selOption(sid, what) {
  return $(sid)[$(sid).selectedIndex][what ? 'innerHTML' : 'value'];
}

/* Делает красивую установку/удаление атрибута disabled для input type="checkbox" */
function setDisabled(chid, action) {
  var state = $(chid).disabled;
  if(action) {
    if(state) return false;
    $(chid).disabled = true;
    $($(chid).nextSibling).classAdd('grey');
  } else {
    if(!state) return false;
    $(chid).disabled = false;
    $($(chid).nextSibling).classRemove('grey');
  }
}

/* Открывает модальное окно и вешает обработчики для его закрытия */
function openModal(oid) {
  var ie = suilib.client.msie,
      szs = suilib.screensizes(),
      w, h;

  $(oid).setstyle('top:-10000px;left:-10000px').show();
  w = $(oid).offsetWidth; h = $(oid).offsetHeight;
  $(oid).hide();

  if(!document.getElementById('overlay')) $(suilib.body).add('div', {'id':'overlay', 'style':'position:' + (ie ? 'absolute' : 'fixed') + ';top:0;left:0;z-index:9998;background:#000000;width:' + (ie ? szs[2]+'px' : '100%') + ';height:' + (ie ? szs[3]+'px' : '100%')}); else $('overlay').show();
  if(!ie) $('overlay').setstyle('opacity:0');
  $('overlay').setstyle('opacity:20');
  $(oid).setstyle('top:' + Math.ceil(szs[1]/2 - h/2) + 'px;left:' + Math.ceil(szs[0]/2 - w/2) + 'px');
  $(oid).show(.4, 'fade');

  if(!document.body.getAttribute('rel')) {
    var close_func = function(e) {
                       if((e.type=='keypress' && e.keyCode==27) || e.type=='click') {
                         $(document.body.getAttribute('rel')).hide();
                         $('overlay').hide();
                       }
                     };
    close_func.$('click', 'overlay').$('keypress', document);
    $(suilib.body).filter('div', 'popup', null, true).filter('div', 'close', null, true).walkwith(function(el) {
      var tid = $(el).getAttribute('id');
      close_func.$('click', tid);
    });
  }
}

/* Определяет по числу дополнительный это матч или турнирный
  (второй параметр для проверенных данных, когда строковое значение по-любому является названием допматча)
*/
function matchType(num, checked_data) {
  var pnum = parseInt(num, 10);
  return !!((checked_data ? !isNaN(pnum) : (typeof num=='string' && num.length > 2) || pnum > $total[1] || pnum < 0) && pnum != -100);
}

/* Возвращает массив данных конкретной команды */
function getComData(c, full_search) {
  if($isGroups) {
    var grn = selOption($isGroups, true);
    if($isGroups.disabled || full_search) { // ищем по всем подхэшам
      for(var i in data[$key]) if(i!='service' && i!='extra' && data[$key][i][c.toString()]) return data[$key][i][c.toString()];
    } else return data[$key][grn.replace(/\&nbsp;|\s+$/g, '')][c.toString()]; // ищем в хэше с ключом, равным названию группы
  } else return data[$key][c.toString()]; // ищем в главном и единственном хэше
}

/* Возвращает массив чисел забитых мячей из строк результатов */
function getCount() {
  var results = [];
  for(var i=0,l=arguments.length; i<l; i++) results.push(arguments[i] ? arguments[i].match(/\^/g).length : 0);
  return results;
}

/* Возвращает готовый метод для вставки эмблемы команды */
function getEmblem(c, side) {
  for(var i in emblems) if(i==c) return add('img', {'align':'top', 'style':'padding-' + (side ? 'left' : 'right') + ':5px', 'src':emblems[i]});
}

/* Подготовка страницы в зависимости от заполненности хэша данных */
function pagePrepare() {
  $('mmnu').empty(true, true);
  if(!objTools.length(data)) {
    $('first_start').show();
    $('main').hide();
    makeHeader('Первый запуск');
  } else {
    $('first_start').hide();

    for(var i in data) $('mmnu').add('li', {'class':'hds'}, [add('b', null, [addtext(i)])]);

    navi();
    if(!$url.admin) {
      $('admin').hide();
      $('main').classAdd('readonly');
      $('toggler').hide();
    }

    tabs.init({apply:[
      { hds : 'hds', open : $url.champ, callback : function(a,b,c) {
        $url.champ = c;
        navi(true);
        $key = a.firstChild.html();
        $transitional_russian_champ_mod = $key.find('Чемпионат России 2011 (II этап)');
        loadData();
      }},
      { els : 'inner_els', hds : 'inner_hds', open : $url.tab, callback : function(a,b,c) {
        $url.tab = c;
        navi(true);
      }}
    ]});
    if(!$url.backup.tab) tabs.openTab(tabs.all[1], tabs.all[1].hds[$isResults ? 0 : 1]); // автооткрытие рабочей вкладки
    $('main').show();
  }
}

/* Загрузка данных на страницу по ключу */
function loadData(tour_num) {
  var obj = data[$key], tn = 1, all_cn = {}, tour = {}, nobj = {};

  $isResults = obj.service.results || false; // глобально запоминаем флаг результатов
  $ratio = obj.service.ratio || 2; // глобально запоминаем коэффициент схемы игр во всех стадиях
  $isGroups = false;
  $extra_names = {};

  // Готовим блок ввода
  $('count_home').value = $('count_guest').value = $('count_home_ps').value = $('count_guest_ps').value = '0';
  $('group_div').empty(true, true);
  $('input_tour_div').empty(true, true);
  $('tech').checked = false;
  $('extra_group_span').empty(true, true);
  $('extra_group_span').show(); $('extra_group_inp').hide();
  if(!$isResults) {
    $('extra_ps_span').hide();
    $('extra_ps_div').hide();
  }

  try { $('count_home').focus(); } catch(err) {}
  $('match_add').disabled = true;
  $('bombs_input').empty(true, true);

  var showCommands = function(cobj, group_name, serv) { // сортирует хэш команд и выводит все данные в таблицу
    var newObj = {}, started = true, keys = [];

    for(var i in cobj) if(i!='service' && i!='extra') {
      var cd = cobj[i];
      if((cd[0] + cd[1] + cd[2])!=0) {
        started = false;
        $total[2] = false;
      }
      keys.push(i);

      var res = cd[6];
      for(var j in res) {
        if(!$results[j]) $results[j] = [];
        var rh = {};
        rh.result = i + '|' + res[j];
        if(group_name) rh.gn = group_name;
        $results[j].push(rh);
      }
    }

    /* Сортируем данные по правилам распределения команд в турнирной таблице (взято из регламента Чемпионата России 2010-20xx годов).
       Выше располагается команда:
       1 - набравшая больше очков;
       2 - с большим числом побед во всех матчах;
       3 - с лучшими показателями по личным встречам**:
           3.1 - с большим числом очков,
           3.2 - с большим количеством побед,
           3.3 - с лучшей разницей мячей,
           3.4 - с большим числом забитых мячей,
           3.5 - с большим числом забитых мячей на чужом поле;
       4 - с лучшей разницей мячей во всех матчах;
       5 - с большим числом забитых мячей во всех матчах;
       6 - с большим числом забитых мячей на чужом поле во всех матчах**;
       7 - победившая в дополнительном матче***.

       **  - учитывается только при включённом сохранении результатов;
       *** - только для турниров с одной группой.
    */
    if(!started) keys.sort(function cmp(a, b) {
      var cr1_a = cobj[a][0]*3 + cobj[a][1] + (cobj[a][8] ? cobj[a][8] : 0), cr1_b = cobj[b][0]*3 + cobj[b][1] + (cobj[b][8] ? cobj[b][8] : 0); // пункт 1
      if(cr1_a==cr1_b) {
        var cr2_a = cobj[a][0], cr2_b = cobj[b][0]; // пункт 2
        if(cr2_a==cr2_b) {
          var criteries = [];
          if($isResults) {
            var cr3 = {}; cr3[a] = [0, 0, 0, 0, 0]; cr3[b] = [0, 0, 0, 0, 0]; // [Очки, победы, МЗ, МП, МЗ на чужом поле]
            var saveResult = function(hc, gc) { // готовит и записывает в промежуточный хэш данные для сравнений по пункту 3
              for(var i in cobj[hc][6]) {
                if(cobj[hc][6][i].find(gc)) {
                  var arr = cobj[hc][6][i].split('|'), rm = getCount(arr[1], arr[2]);

                  // Используем правильный счёт при техпоражении
                  var tech = arr[4] ? arr[4].split(':') : false;
                  if(tech) {
                    rm[0] = parseInt(tech[0], 10);
                    rm[1] = parseInt(tech[1], 10);
                  }

                  if(rm[0]>rm[1]) {
                    cr3[hc][0] += 3;
                    cr3[hc][1] += 1;
                  } else if(rm[0]==rm[1]) {
                    cr3[hc][0]++; cr3[gc][0]++;
                  } else {
                    cr3[gc][0] += 3;
                    cr3[gc][1] += 1;
                  }

                  cr3[hc][2] += rm[0]; cr3[gc][3] += rm[0];
                  cr3[hc][3] += rm[1]; cr3[gc][2] += rm[1];
                  cr3[gc][4] += rm[1];
                }
              }
            };

            saveResult(a, b); saveResult(b, a);
            criteries.push([cr3[a][0], cr3[b][0]]); // пункт 3.1
            criteries.push([cr3[a][1], cr3[b][1]]); // пункт 3.2
            criteries.push([cr3[a][2] - cr3[a][3], cr3[b][2] - cr3[b][3]]); // пункт 3.3
            criteries.push([cr3[a][2], cr3[b][2]]); // пункт 3.4
            criteries.push([cr3[a][4], cr3[b][4]]); // пункт 3.5
          }

          criteries.push([cobj[a][3] - cobj[a][4], cobj[b][3] - cobj[b][4]]); // пункт 4
          criteries.push([cobj[a][3], cobj[b][3]]); // пункт 5

          for(var i=0,l=criteries.length; i<l; i++) {
            var cp = criteries[i];
            if(cp[0]!=cp[1]) return (cp[0] < cp[1]) ? 1 : -1;
          }

          if($isResults) {
            var cr6_a = 0, cr6_b = 0; // пункт 6
            for(var i in $results) {
              for(var j=0,l=$results[i].length; j<l; j++) {
                var arr = $results[i][j].result.split('|');
                if(arr[1]==a) cr6_a += arr[5] ? parseInt(arr[5].split(':')[1], 10) : getCount(arr[3])[0];
                if(arr[1]==b) cr6_b += arr[5] ? parseInt(arr[5].split(':')[1], 10) : getCount(arr[3])[0];
              }
            }

            if(cr6_a==cr6_b) {
              if(!cobj.extra) return 0; // пропускаем пункт, если турнир с несколькими группами

              var cr7_a = 0, cr7_b = 0; // пункт 7
              for(var i in cobj.extra) {
                for(var j=0,l=cobj.extra[i].length; j<l; j++) {
                  var arr = cobj.extra[i][j];
                  if(arr.find(a) && arr.find(b)) {
                    var res = arr.split('|'), rm = getCount(res[2], res[3]), ps = res[4] ? res[4].split(':') : false;

                    // Используем правильный счёт при техпоражении
                    var tech = res[5] ? res[5].split(':') : false;

                    if(res[0]==a) {
                      if(tech) {
                        cr7_a += parseInt(tech[0], 10);
                        cr7_b += parseInt(tech[1], 10);
                      } else {
                        cr7_a += rm[0] + parseInt(ps ? ps[0] : 0, 10);
                        cr7_b += rm[1] + parseInt(ps ? ps[1] : 0, 10);
                      }
                    } else {
                      if(tech) {
                        cr7_b += parseInt(tech[0], 10);
                        cr7_a += parseInt(tech[1], 10);
                      } else {
                        cr7_b += rm[0] + parseInt(ps ? ps[0] : 0, 10);
                        cr7_a += rm[1] + parseInt(ps ? ps[1] : 0, 10);
                      }
                    }
                  }
                }
              }
              if(cr7_a==cr7_b) return 0; // заглушка на случай, если дополнительный матч еще не добавлен
              return (cr7_a < cr7_b) ? 1 : -1;
            }
            return (cr6_a < cr6_b) ? 1 : -1;
          }
        }
        return (cr2_a < cr2_b) ? 1 : -1;
      }
      return (cr1_a < cr1_b) ? 1 : -1;
    });
    for(var i=0,l=keys.length; i<l; i++) newObj[keys[i]] = cobj[keys[i]];

    // Рисуем шапку турнирной таблички
    $('tt').add('table', {'class':'z bord ieFix m10', 'width':'100%', 'id':'tt_table_' + tn}, [
      add('tbody', null, [
        add('tr', null, [
          add('th', {'innerHTML':'Место'}),
          add('th', {'width':'69%', 'innerHTML':'Команда'}),
          add('th', {'class':'c', 'innerHTML':'И'}),
          add('th', {'class':'c', 'innerHTML':'В'}),
          add('th', {'class':'c', 'innerHTML':'Н'}),
          add('th', {'class':'c', 'innerHTML':'П'}),
          add('th', {'class':'c', 'innerHTML':'Голы'}),
          add('th', {'class':'c', 'innerHTML':'Очки'})
        ])
      ])
    ]);

    // Выводим отсортированные команды в таблицу
    var cn = $transitional_russian_champ_mod && group_name && group_name=='Группа B' ? 9 : 1;
    for(var i in newObj) {
      if(i=='service' || i=='extra') continue;

      var el = newObj[i], svc = serv || cobj.service, cls = '', ttl = '';

      // Определяем, какой нынче тур идет
      var gn = el[0] + el[1] + el[2];
      if(!tour[gn]) tour[gn] = 0;
      tour[gn]++;

      // Подсвечиваем зоны еврокубков и вылета
      for(var j in svc) {
        if(j=='edited' || j=='results' || j=='ratio') continue;
        if(svc[j] && $(svc[j]).hasa(cn)!==false && ($transitional_russian_champ_mod && group_name ? svc[j][1]==group_name : true)) {
          cls = $transitional_russian_champ_mod && j=='st' ? 'le' : j;
          ttl = typeof svc[j][0]=='string' ? svc[j][0] : $alias[j];
        }
      }

      var cname = []; // тут будет название команды со всеми картинками
      cname.push(getEmblem(i)); cname.push(addtext(i));

      // Добавляем команде заслуги прошлого сезона
      for(var j=0,l=el[7].length; j<l; j++) {
        var item = el[7][j];
        cname.push(add('img', {'align':'top', 'alt':$alias[item][0], 'title':$alias[item][0], 'style':'padding-left:5px', 'src':$alias[item][1]}));
      }

      // Пишем это всё
      $($('tt_table_' + tn).firstChild).add('tr', (cn % 2 == 0) ? {'class':'hl'} : null, [
        add('td', {'class':cls, 'title':ttl, 'innerHTML':String(cn)}),
        add('td', {'class':'nc bb'}, cname),
        add('td', {'innerHTML':String(gn)}),
        add('td', {'innerHTML':String(el[0])}),
        add('td', {'innerHTML':String(el[1])}),
        add('td', {'innerHTML':String(el[2])}),
        add('td', {'noWrap':'noWrap', 'innerHTML':el[3] + ' &mdash; ' + el[4]}),
        add('td', {'class':'bb' + (el[8] ? ' red' : ''), 'innerHTML':String(el[0]*3 + el[1] + (el[8] ? el[8] : 0))})
      ]);
      cn++;
    }

    var total = $transitional_russian_champ_mod ? 44 : ((cn - 1) * $ratio - $ratio);
    if(!all_cn[total]) all_cn[total] = 0;
    if($transitional_russian_champ_mod) all_cn[total] = 16; else all_cn[total] += cn - 1;
    tn++;

    return newObj;
  };

  // Обрабатываем данные и запускаем функцию их сортировки и вывода в таблицу
  $results = {}; $total[2] = true;
  $('tt').empty(true, true);

  var gcn = 1, list = {};
  for(var i in obj) if(i!='service' && i!='extra') {
    var cd = obj[i];

    if('length' in cd) {
      nobj = showCommands(obj);
      if(obj.extra) nobj.extra = obj.extra;
      if(obj.service) nobj.service = obj.service;
      data[$key] = nobj; // обновляем весь глобальный хэш
      list = data[$key];
      break;
    } else {
      $('tt').add('h3', {'innerHTML':i});

      // Формируем селектор выбора группы
      var gr = $('group_div'), grn = !!(gcn == $url.backup.group);
      if(!$isGroups) {
        gr.classAdd('m15');
        gr.add('select').$('change', function(e) {
          var sel = e.target || e.srcElement,
              sHTML = selOption(sel, true);

          // Перезаполняем селекторы с командами
          createComsSelectors(data[$key][sHTML.replace(/\&nbsp;|\s+$/g, '')]);
          inputHandler('com_home');

          // Сохраняем выбранную группу для удобства ввода данных
          $url.backup.group = selOption(sel);
        });
        $isGroups = gr.firstChild;
      }
      addOption($isGroups, [{'value':gcn, 'innerHTML':i + '&nbsp;&nbsp;', 'selected':grn}]);

      nobj = showCommands(cd, i, obj.service);
      data[$key][i] = nobj; // обновляем часть глобального хэша
      if(grn) list = data[$key][i];

      gcn++;
    }
  }

  // Пишем заголовок
  makeHeader($key);

  // Дописываем текущий тур или стадию дополнительных матчей в заголовок
  var keys = [], tk = [], s_tour = {}, s_all_cn = {};
  keys = objTools.array(tour, true);
  keys.sort(function cmp(a, b) {
    if(tour[a]==tour[b]) {
      if(a==b) return 0;
      return (a > b) ? 1 : -1;
    }
    return (tour[a] > tour[b]) ? -1 : 1;
  });
  for(var i=0,l=keys.length; i<l; i++) s_tour[keys[i]] = tour[keys[i]];

  for(var i in all_cn) tk.push(i);
  tk.sort(function cmp(a, b) {
    if(all_cn[a]==all_cn[b]) {
      if(a==b) return 0;
      return (a > b) ? 1 : -1;
    }
    return (all_cn[a] > all_cn[b]) ? -1 : 1;
  });
  for(var i=0,l=tk.length; i<l; i++) s_all_cn[tk[i]] = all_cn[tk[i]];

  $total[0] = $transitional_russian_champ_mod ? 44 : (objTools.length(list, ['service', 'extra']) * $ratio - $ratio);
  $total[1] = getMax(tk);
  $total[3] = (objTools.parse(s_all_cn) == objTools.parse(s_tour));
  if(keys[0]!=0) $('hdr').innerHTML += ' :: ' + ($total[3] ? (obj.extra && parseInt(objTools.lastKey(obj.extra).split('|')[0], 10) > $total[0] ? objTools.lastKey(obj.extra).split('|')[1] : 'Итоговая таблица') : 'после ' + keys[0] + ' тура'); else {
    if(keys.length==1) {
      if(obj.extra) $('hdr').innerHTML += ' :: ' + objTools.lastKey(obj.extra).split('|')[1];
    } else {
      $('hdr').innerHTML += ' :: ' + 'после ' + keys[1] + ' тура'; // мне больше нравится, когда сразу так пишется, если я начал туры забивать
    }
  }

  // Заполняем селектор ввода тура и примерно определяем тур, выбранный для ввода по умолчанию
  if($isResults) {
    var extraManual = function(sid, action) { // включает ручной ввод названия стадии дополнительного матча
      if(action) {
        $(sid).selectedIndex = $(sid).length - 1;
        $($(sid).parentNode).hide();
        $(sid + '_inp').show();
        try { $(sid + '_inp').focus(); } catch(err) {};
      }
      extraHandler('extra');
    };

    var next = keys[0] == $total[0] ? keys[0] : (keys.length > 2 ? parseInt(keys[0], 10) + 1 : getMin(keys) + 1);

    $('input_tour_div').classAdd('m15');
    $('input_tour_div').add('span', {'class':'bb', 'innerHTML':'Матч тура:&nbsp;&nbsp;'}, [
      add('select', {'id':'input_tour'}).$('change', function(e) {
        var sel = e.target || e.srcElement;
        if(parseInt(selOption(sel), 10)>$total[0]) $(sel).selectedIndex = 0;
      })
    ]);
    $('extra_block').show();
    $('extra_group_span').add('select', {'id':'extra_group'}).$('change', function(e) {
      var sel = e.target || e.srcElement,
          selOpt = selOption(sel);
      if(parseInt(selOpt, 10)>$total[0] && parseInt(selOpt, 10)<=$total[1]) $(sel).selectedIndex = 0;
      extraManual(sel.id, selOpt=='add');
    });

    // Сортируем хэш с результатами по убыванию туров
    if(obj.extra) {
      var tours = [], before = [], after= [], tr = {};
      for(var i in obj.extra) {
        var num = parseInt(i, 10), parsed = i.split('|');
        $extra_names[num] = parsed[1];
        tours.push(num);
      }
      tours.sort(function cmp(a, b) {
        if(a==b) return 0;
        return (a < b) ? (a < 0 && b < 0) ? 1 : -1 : (a < 0 && b < 0) ? -1 : 1;
      });
      for(var i=0,l=tours.length; i<l; i++) {
        var item = tours[i];
        if(item < 0) before.push(item); else after.push(item);
        var key = item + '|' + $extra_names[item];
        tr[key] = obj.extra[key];
      }
      data[$key].extra = tr;
    }

    // Добавляем сначала допматчи, сохранённые до туров
    if(obj.extra) for(var i=0; i<before.length; i++) addOption($('extra_group'), [{'value':before[i], 'class':'shl red', 'innerHTML':$extra_names[before[i]].toLowerCase() + '&nbsp;&nbsp;', 'selected':(before[i]==getMin(before) && $total[2] && !$total[3])}]);

    // Затем добавляем туры для переигровки
    for(var i=1; i<=$total[1]; i++) {
      addOption($('input_tour'), [{'value':i, 'innerHTML':String(i) + '&nbsp;&nbsp;', 'selected':i==next}]);
      addOption($('extra_group'), [{'value':i, 'innerHTML':'переигровка в ' + String(i) + ' туре&nbsp;&nbsp;', 'selected':(i==getMin(keys) && !$total[2] && !$total[3])}]);
    }

    // И в конце допматчи, сохранённые после туров
    if(obj.extra) for(var i=0; i<after.length; i++) addOption($('extra_group'), [{'value':after[i], 'class':'shl red', 'innerHTML':$extra_names[after[i]].toLowerCase() + '&nbsp;&nbsp;', 'selected':(after[i]==getMax(after) && !$total[2] && $total[3])}]);

    addOption($('extra_group'), [{'value':'add', 'class':'shl', 'innerHTML':'добавить новую&nbsp;&nbsp;'}]);
    if(($total[2] || $total[3]) && !obj.extra) extraManual('extra_group', true);
  } else {
    $('input_tour_div').classRemove('m15');
    $('extra_block').hide();
  }

  // Создаем и заполняем селекторы выбора команд + обновляем текущее число игр в группе ($total[0])
  createComsSelectors(list);

  $empty = true;

  // Генерим таблицу результатов
  createResults(tour_num || null);

  // Генерим таблицу бомбардиров
  createBombers($url.bombs[0], $url.bombs[1]);

  // Когда же был последний сэйв?
  $('content').filter('div','instr',null,true).filter('b',null,null,true).walkwith(function(el) {
    el.html(obj.service.edited);
  });
}

/* Генерация таблицы результатов */
function createResults(tour) {
  var show = -100, this_results = objTools.clone($results);

  // Добавляем в промежуточный глобальный хэш результаты дополнительных матчей
  $results = objTools.extend(this_results, data[$key].extra);

  // Автокоррекция параметров из урла
  if(!$url.backup.tour && $url.tour[0]!='-100') $url.tour[0] = false; // если при открытии системы тур не был задан, то для удобства перехода по чемпионатам он сбрасывается
  if(typeof $url.tour[1]!='number' || $url.tour[1] < 0 || $url.tour[1] > 1) $url.tour[1] = 0;

  // Готовим селектор выбора тура, типа вывода и ссылки для печати
  $('rt').empty(true, true);
  $('r_tours_span').empty(true, true);
  $('r_tours_span').add('select', {'id':'r_tours', 'style':suilib.client.msie ? 'width:90px' : ''}).$('change', function(e) {
    var show = parseInt((e.target || e.srcElement).value, 10);
    if(document.getElementById('rt_table')) createResults(show);
  });
  var rsid = $('r_tours');
  $('r_types_span').hide();
  $($('r_print').parentNode).show();
  $($('t_print').parentNode).hide();

  // Создаём таблицу
  $('rt').add('table', {'class':'z bord ieFix m10', 'width':'100%', 'id':'rt_table'}, [add('tbody')]);

  var writeHeader = function(what) { // выводит в таблицу заголовок
    $($('rt_table').firstChild).add('tr', null, [add('th', what)]);
  };

  // Заполняем, что нужно, попутно корректируя ссылки и селекторы в зависимости от глобальных параметров
  if($isResults) {
    if(objTools.length($results)) {
      var matchName = function(num, gn) { // возвращает строку для вывода полного названия тура по его номеру либо вывода названия группы
        return (gn ? num : 'Матчи ' + num + ' тура');
      };

      var restorated = function(str) { // восстанавливает в читабельный вид строчку бомбардиров
        return str ? str.replace(/(\^[^,]+)/g, ' ($1)').replace(/\,/g, ', ').replace(/\^((\d|\+)+)/g, '$1\', ').replace(/, @|@/g, ' - автогол, ').replace(/, %|%/g, ' - с пенальти, ').replace(/,\ ?\)/g, ')') : '&mdash;';
      };

      var writePhase = function(what, phase_num) { // выводит в таблицу стадию, тур или группу
        var cls = 'red'; // класс, добавляемый к ячейке выигравшей команды
            matches = {};

        // Прогоняем и парсим результаты матчей для объединения парных матчей => на выходе получаем хэш matches с ключами (либо строками названий пар команд, либо названий туров/групп)
        for(var i=0,l=what.length; i<l; i++) {
          var type = typeof what[i]=='string',
              mtch = type ? what[i].split('|') : what[i].result.split('|'),
              key = false;

          if(type) {
            for(var j in matches) if(j.find(mtch[0]) && j.find(mtch[1])) key = j;
            if(!key) {
              var pair = mtch[0] + '|' + mtch[1];
              matches[pair] = [];
              key = pair;
            }
          } else {
            key = what[i][byGroups ? 'tour' : 'gn'] || phase_num;
            if(!matches[key]) matches[key] = [];
          }
          matches[key].push(mtch);
        }

        // Выводим все данные в таблицу
        for(var i in matches) {
          var coms = i.split('|'), type = coms.length > 1, pair_phase = matches[i].length > 1, winners = {};

          // Сначала выводим строку c дополнительным заголовком тура/группы (для мультигрупповых турниров)
          if(!type && $isGroups) {
            $($('rt_table').firstChild).add('tr', null, [
              add('td', {'colSpan':'3', 'class':'l blue bb', 'innerHTML':matchName(i, !byGroups)})
            ]);
          }

          for(var j=0,l=matches[i].length; j<l; j++) {
            var item = matches[i][j], counts = getCount(item[2], item[3]);

            // Добавляем к командам эмблемы, если есть
            var leftc = [], rightc = [];
            leftc.push(addtext(item[0])); leftc.push(getEmblem(item[0], true));
            rightc.push(getEmblem(item[1])); rightc.push(addtext(item[1]));

            // Матч выигран в серии пенальти?
            var ps = item[4] ? item[4].split(':') : false, dv = false;

            // Матч выигран в дополнительное время?
            if(type && !ps) {
              var minutes = ((item[2] ? item[2] : '') + (item[3] ? item[3] : '')).match(/\^((\d|\+)+)/g) || [];
              for(var k=0,m=minutes.length; k<m; k++)
                if(parseInt(minutes[k].replace(/\^/, ''), 10) > 90) dv = true;
            }

            // Было записано "техническое поражение"?
            var tech = item[5] ? item[5].split(':') : false;

            // Кто же в итоге победил?
            var leftw = '', rightw = '';
            if(type) {
              if(!winners[item[0]]) winners[item[0]] = 0; if(!winners[item[1]]) winners[item[1]] = 0;
              if(tech) {
                winners[item[0]] = parseInt(tech[0], 10);
                winners[item[1]] = parseInt(tech[1], 10) * (pair_phase ? 1.5 : 1);
              } else {
                winners[item[0]] += counts[0] + parseInt(ps ? ps[0] : 0, 10);
                winners[item[1]] += counts[1] * (pair_phase ? 1.5 : 1) + parseInt(ps ? ps[1] : 0, 10);
              }
              if(!pair_phase) {
                if(winners[item[0]] > winners[item[1]]) leftw = ' ' + cls;
                else if(winners[item[0]]==0 && winners[item[1]]==0) leftw = ''; // отменяем подсветку для безголевой ничьи
                else rightw = ' ' + cls;
              }
            }

            // Теперь выводим сами матчи с результатами
            $($('rt_table').firstChild).add('tr', {'class':'hl'}, [
              add('td', {'width':'49%', 'class':'r bb' + leftw}, leftc),
              add('td', {'noWrap':'noWrap', 'innerHTML':counts[0].toString() + ' : ' + counts[1].toString() + (dv ? ('<br /><b class="s13">(д.в.)</b>') : '') + (ps ? ('<br /><b>(' + ps[0].toString() + ' : ' + ps[1].toString() + ')</b>') : '') + (tech ? ('<br /><b class="' + cls + '">(' + tech[0].toString() + ' : ' + tech[1].toString() + ')</b>') : '')}),
              add('td', {'width':'49%', 'class':'l bb' + rightw}, rightc)
            ]);

            $($('rt_table').firstChild).add('tr', null, [
              add('td', {'class':'r', 'innerHTML':restorated(item[2])}),
              add('td'),
              add('td', {'class':'l', 'innerHTML':restorated(item[3])})
            ]);

            if(tech) $($('rt_table').firstChild).add('tr', null, [add('td', {'class':'bb '+cls, 'innerHTML':'Засчитано техническое поражение', 'colSpan':'3'})]);
          }

          // И в конце выводим победителя пары, прошедшего в следующую допстадию (если надо)
          if(type && pair_phase) {
            var winner = winners[coms[0]] > winners[coms[1]] ? coms[0] : coms[1];
            $($('rt_table').firstChild).add('tr', null, [add('td', {'class':'bb', 'innerHTML':'Победитель пары:&nbsp;&nbsp;&nbsp;<b class="' + cls + '">' + winner + '</b>', 'colSpan':'3'})]);
          }
        }
      };


      // Сортируем хэш с результатами по убыванию туров
      var tours = [], tr = {};
      for(var i in $results) {
        var num = parseInt(i, 10);
        tours.push(num);
      }
      tours.sort(function cmp(a, b) {
        if(a==b) return 0;
        return (a > b) ? (a < 0 && b < 0 ? 1 : -1) : (a < 0 && b < 0 ? -1 : 1);
      });
      for(var i=0,l=tours.length; i<l; i++) {
        var item = tours[i], key = $results[item] ? item : item + '|' + $extra_names[item];
        tr[item] = $results[key];
      }
      $results = tr;

      // Заполняем селектор выбора тура с учетом взятого из урла или автоматически выбранного исходного тура
      show = String(tour || ($results[$url.tour[0]] || $url.tour[0]=='-100' ? $url.tour[0] : (tours[0] || 1)));
      for(var i in $results) addOption(rsid, [{'value':i, 'innerHTML':(matchType(i) ? $extra_names[i].toLowerCase() : 'тур ' + i) + '&nbsp;&nbsp;', 'class':matchType(i) ? 'shl red' : '', 'selected':i==show}]);

      // Показываем селектор формата вывода
      if($isGroups && show=='-100') {
        $('r_types_span').show();
        $('r_types').selectedIndex = $url.tour[1];
      }

      // Меняем переменную в урле
      $url.tour[0] = parseInt(show, 10);
      navi(true);

      // Окончательно подготавливаем данные и заполняем таблицу
      if(show=='-100') {
        var all_results = {}, byGroups = $isGroups && $url.tour[1]==1;
        if(byGroups) { // переформировываем хэш, если надо вывести по группам
          for(var i in $results) {
            if(i > $total[1] || i < 0) all_results[i] = $results[i]; else {
              for(var j=0,l=$results[i].length; j<l; j++) {
                var match = $results[i][j];
                if(!all_results[match.gn]) all_results[match.gn] = [];
                var tr = {};
                tr.result = match.result;
                tr.tour = i;
                all_results[match.gn].push(tr);
              }
            }
          }

          // Сортируем новый хэш по группам
          var s_all_results = {}, before_keys = [], groups_keys = [], after_keys = [], final_keys = [];
          for(var i in all_results) {
            if(!isNaN(parseInt(i, 10))) {
              if(i < 0) before_keys.push(i); else after_keys.push(i);
            } else groups_keys.push(i);
          }
          groups_keys.sort();
          final_keys = after_keys.concat(groups_keys).concat(before_keys);
          for(var i=0,l=final_keys.length; i<l; i++) s_all_results[final_keys[i]] = all_results[final_keys[i]];
          all_results = s_all_results;

        } else all_results = $results;

        for(var i in all_results) {
          writeHeader({'innerHTML':matchType(i, byGroups) ? $extra_names[i] : matchName(i, byGroups), 'colSpan':'3'});
          writePhase(all_results[i], i);
        }
      } else {
        writeHeader({'innerHTML':matchType(show) ? $extra_names[show] : matchName(show), 'colSpan':'3'});
        writePhase($results[show], show);
      }

    } else {
      writeHeader({'innerHTML':'Не сыграно ни одного матча'});
    }
    addOption(rsid, [{'value':'-100', 'innerHTML':'все&nbsp;&nbsp;', 'selected':show=='-100'}]);
  } else {
    addOption(rsid, [{'value':'null', 'innerHTML':'нет данных&nbsp;&nbsp;'}]);
    writeHeader({'innerHTML':'Сохранение результатов было отключено'});
    $($('r_print').parentNode).hide();
    $($('t_print').parentNode).show();
  }
}

/* Генерация таблицы бомбардиров

   type - тип таблицы для вывода (0 - по голам, 1 - по командам)
   sorting - сортировка (0 - по фамилии, 1 - по командам (только для type = 0), 2 - по голам (только для type = 1))
*/
function createBombers(type, sorting) {
  var obj = data[$key], fullObj = {}, nobj = {}, newObj = {}, cn = 1;

  // Автокоррекция входных параметров (в том числе, полученных из урла)
  if(typeof(type)!='number' || type < 0 || type > 1) type = 0;
  if(typeof(sorting)!='number' || sorting < 0 || sorting > 2) sorting = 0;

  // Готовим селекторы
  var opts = $('b_sorts'), types = $('b_types'), sel = (opts[(type == 0) ? 2 : 1].selectedIndex) || (type == 0 && sorting == 2) || (type == 1 && sorting == 1) ? 0 : sorting;
  types.selectedIndex = type;
  opts.selectedIndex = sel;
  opts.options[1].disabled = (type == 0) ? false : true;
  opts.options[2].disabled = (type == 0) ? true : false;

  // Меняем переменную в урле
  $url.bombs = [type, sel];
  navi(true);

  // Сортируем и переформировываем данные в соответствие с выбранным способом отображения
  // и создаем таблицу в соответствие с выбранным типом
  $('bt').empty(true, true);
  $('content').filter('div','instr',null,true).filter('div','pages',null,true).walkwith(function(el) {
    el.html('В скобках указаны голы, забитые с пенальти');
  });

  // Сортируем бомбардиров каждой команды по фамилии или забитым мяча (=> newObj (полный отсортированный клон data[$key]) для использования при type = 1)
  // Код вынесен сюда, чтобы по фамилии сортировалось всегда при первом выводе (надо для селектора списка бомбардиров)
  var s = (sorting == 2) ? true : false;
  var sortBombers = function(cobj) {
    newObj = objTools.clone(cobj);
    for(var i in cobj) {
      if(i=='service' || i=='extra') continue;
      var keys = [], bombs = cobj[i][5];
      if(objTools.length(bombs)) {
        $empty = false;
        newObj[i][5] = {};
        keys = objTools.array(bombs, true);

        keys.sort(function cmp(a, b) {
          if(s) {
            a = bombs[a][0];
            b = bombs[b][0];
          }
          if(a==b) return 0;
          return (a < b) ? (s ? 1 : -1) : (s ? -1 : 1);
        });

        for(var j=0,l=keys.length; j<l; j++) {
          newObj[i][5][keys[j]] = bombs[keys[j]];
        }
      }
    }

    return newObj;
  };

  // Обрабатываем данные и запускаем функцию их сортировки => на выходе получаем хэш fullObj (либо клон data[$key], либо объединение команд из всех групп)
  for(var i in obj) if(i!='service' && i!='extra') {
    var cd = obj[i];

    if('length' in cd) {
      nobj = sortBombers(obj);
      fullObj = nobj;
      if(!s) data[$key] = nobj; // обновляем весь глобальный хэш
      break;
    } else {
      nobj = sortBombers(cd);
      fullObj = objTools.extend(fullObj, nobj);
      if(!s) data[$key][i] = nobj; // обновляем часть глобального хэша
    }
  }

  switch(type) {
  case 1:
    // Бомбардиров нет
    if($empty) {
      $('bt').add('table', {'class':'z bord ieFix m10', 'width':'100%'}, [add('tbody', null, [add('tr', null, [add('th', {'innerHTML':'Голов пока никто не забивал'})])])]);
      $('content').filter('div','instr',null,true).filter('div','pages',null,true).walkwith(function(el) {
        el.html(' ');
      });
      break;
    }

    // Рисуем шапочку
    $('bt').add('table', {'class':'z bord ieFix m10', 'width':'100%', 'id':'bt_table'}, [
      add('tbody', null, [
        add('tr', null, [
          add('th', {'innerHTML':'Команды'}),
          add('th', {'width':'99%', 'innerHTML':'Бомбардиры'})
        ])
      ])
    ]);

    // Выводим отсортированных бомбардиров по командам
    for(var i in fullObj) {
      if(i=='service' || i=='extra') continue;

      var el = fullObj[i], tempObj = {}, isBombs = objTools.length(fullObj[i][5]), auto = 0;
      if(isBombs) {
        for(var j in el[5]) {
          var cur = el[5][j], fst = el[5][j][0];
          if(typeof cur[1]=='string') auto = auto + fst;
          else {
            if(s) {
              if(!tempObj[fst]) tempObj[fst] = [];
              tempObj[fst].push([j, cur[1]]);
              tempObj[fst].sort();
            }
          }
        }
        if(objTools.length(tempObj)) el[5] = tempObj;
      }

      // Отдельно считаем количество мячей, забитых командой в допматчах после группы (учитывая автоголы)
      // Тут же будем считать мячи, записанные засчёт "технических поражений"
      var extra_goals = 0, tp_goals = 0;
      for(var j in $results) {
        for(var k=0,l=$results[j].length; k<l; k++) {
          var type = typeof $results[j][k]=='string',
              arr  = type ? $results[j][k].split('|') : $results[j][k].result.split('|');

          if(j > 0 && arr[5]) {
            var tech = arr[5].split(':'), tp_part = false;
            if(arr[0]==i) tp_part = tech[0];
            if(arr[1]==i) tp_part = tech[1];

            if(tp_part) tp_goals += parseInt(tp_part, 10);
          }

          if(j > $total[1]) {
            var part = false;
            if(arr[0]==i) part = arr[2];
            if(arr[1]==i) part = arr[3];

            extra_goals += tp_goals;
            if(part && !arr[5]) {
              extra_goals += getCount(part)[0];
              var extra_auto = part.match(/\@/g);
              if(extra_auto) auto += extra_auto.length;
            }
          }
        }
      }

      var cname = [], extended = [];
      cname.push(getEmblem(i)); cname.push(addtext(i));
      if(auto!=0) extended.push(add('div', {'class':'s11', 'innerHTML':'(из них автоголов: <b>' + String(auto) + '</b>' + (tp_goals!=0 ? ',' : ')')}));
      if(tp_goals!=0) extended.push(add('div', {'class':'s11', 'innerHTML':(auto!=0 ? '&nbsp;' : '(') + 'из них засчёт<br />&nbsp;технических поражений: <b>' + String(tp_goals) + '</b>)'}));

      $($('bt_table').firstChild).add('tr', (cn % 2 == 0) ? {'class':'hl'} : null, [
        add('td', {'class':'nc', 'vAlign':'top'}, [
          add('div', {'class':'m5 bb'}, cname),
          add('div', {'innerHTML':'Всего забито: ' + '<b>' + String(el[3] + extra_goals) + '</b>'}, extended)
        ]),
        add('td', {'class':'l', 'id':'bombs_list_'+cn})
      ]);

      if(isBombs)
        for(var j in el[5]) {
          var cur = el[5][j];
          if(typeof cur[1]=='string') continue;
          if(s) {
            var formatted = cur.walkwith(function(el) {
              return String(el[0] + (el[1] == 0 ? '' : ' (' + el[1] + ')'));
            });
          }
          $('bombs_list_'+cn).add('div', {'class':'m5', 'innerHTML':(s ? '<b>' : '') + String(j) + ' &mdash; ' + (s ? '</b>' : '') + (s ? formatted.join(', ') : '<b>' + String(cur[0]) + (cur[1] == 0 ? ' ' : ' (' + String(cur[1]) + ') ') + '</b>')});
        }
      cn++;
    }
  break;

  case 0:
  default:
    // Сортируем бомбардиров всех команд по забитым мячам и фамилии или команде => newObj (абсолютно новый отсортированный хэш с ключами = забитые мячи + auto)
    var newObj = {}, tempObj = {}, transfered = {}, keys = [], s = (sorting == 1) ? true : false;
    for(var i in fullObj) {
      if(i=='service' || i=='extra') continue;
      var el = fullObj[i][5];
      if(objTools.length(el))
      for(var j in el) {
        var bd = el[j], ss = (typeof el[j][1] == 'string');

        if(!ss && j.match(/\*$/i)) { // выдираем в отдельный хэш игроков, перешедших в другую команду внутри турнира, с объединением их статистики
          if(!transfered[j]) transfered[j] = [0, 0, []];
          transfered[j][0] += bd[0];
          transfered[j][1] += bd[1];
          transfered[j][2].push(i);
          continue;
        }

        var key = ss ? 'auto' : bd[0];
        var ba = [j, ss ? bd[0] : bd[1], ss ? bd[1] : i];
        if(!ss) keys.push(parseInt(key, 10));
        if(!newObj[key]) newObj[key] = [];
        newObj[key].push(ba);
      }
    }

    // Бомбардиров нет
    if($empty) {
      $('bt').add('table', {'class':'z bord ieFix m10', 'width':'100%'}, [add('tbody', null, [add('tr', null, [add('th', {'innerHTML':'Голов пока никто не забивал'})])])]);
      $('content').filter('div','instr',null,true).filter('div','pages',null,true).walkwith(function(el) {
        el.html(' ');
      });
      break;
    }

    // Внедряем объединённых бомбардиров из transfered в newObj
    for(var i in transfered) {
      var stat = transfered[i];
      if(keys.hasa(stat[0])===false) keys.push(parseInt(stat[0], 10));
      if(!newObj[stat[0]]) newObj[stat[0]] = [];
      newObj[stat[0]].push([i, stat[1], stat[2].join(', ')]);
    }

    if(objTools.length(newObj)) {
      keys.sort(function cmp(a, b) {
        if(a==b) return 0;
        return (a < b) ? 1 : -1;
      });

      for(var i=0,l=keys.length+1; i<l; i++) {
        var arr = newObj[keys[i]] ? keys[i] : 'auto';
        if(!newObj[arr]) continue;
        newObj[arr].sort(function cmp(a, b) {
          var p1 = s ? a[2] : a[0], p2 = s ? b[2] : b[0];
          if(p1==p2) {
            if(a[0]==b[0]) return 0;
            return (a[0] < b[0]) ? -1 : 1;
          }
          return (p1 < p2) ? -1 : 1;
        });
        tempObj[arr] = newObj[arr];
      }
      newObj = tempObj;
    }

    // Рисуем шапочку
    $('bt').add('table', {'class':'z bord ieFix m10', 'width':'100%', 'id':'bt_table'}, [
      add('tbody', null, [
        add('tr', null, [
          add('th', {'class':'c', 'innerHTML':'Голы'}),
          add('th', {'width':'99%', 'innerHTML':'Игроки'})
        ])
      ])
    ]);

    // Выводим отсортированных бомбардиров по голам
    for(var i in newObj) {
      var a = (i == 'auto') ? true : false;

      // Объединяем лузеров, забивших автоголы разным командам
      if(a) {
        var tmp = {};
        for(var j=0; j<newObj[i].length; j++) {
          if(tmp[newObj[i][j][0]]==null) tmp[newObj[i][j][0]] = j;
          else {
            newObj[i][tmp[newObj[i][j][0]]][1] += newObj[i][j][1];
            if(newObj[i][tmp[newObj[i][j][0]]][0].match(/\*$/i) && !newObj[i][tmp[newObj[i][j][0]]][2].find(newObj[i][j][2])) newObj[i][tmp[newObj[i][j][0]]][2] = newObj[i][tmp[newObj[i][j][0]]][2] + ', ' + newObj[i][j][2];
            newObj[i].splice(j, 1);
            j--;
          }
        }
        $autogoals = newObj[i]; // сохраняем в глобальный массив всех, кто забивал автоголы
      }

      var formatted = newObj[i].walkwith(function(el) {
        return String(el[0] + ' (' + el[2] + (el[1] !== 0 ? (a && el[1] == 1 ? '' : ', ' + el[1]) : '') + ')');
      });

      $($('bt_table').firstChild).add('tr', (cn % 2 == 0) ? {'class':'hl'} : null, [
        add('td', {'class':'bb', 'vAlign':'top', 'innerHTML':a ? 'в свои ворота' : i}),
        add('td', {'class':'l', 'innerHTML':formatted.join(', ')})
      ]);
      cn++;
    }
  }
}

/* Создание селекторов выбора команды */
function createComsSelectors(list, isGroups, ehCall) {
  // Сохраняем выбранные команды для удобства
  var backup = {
    'home'  : document.getElementById('com_home') && ehCall ? $('com_home').selectedIndex : 0,
    'guest' : document.getElementById('com_guest') && ehCall ? $('com_guest').selectedIndex : 0
  };

  // Очищаем всё
  $('com_home_span').empty(true, true);
  $('com_guest_span').empty(true, true);
  $('com_home_span').show(); $('com_home_inp').hide();
  $('com_guest_span').show(); $('com_guest_inp').hide();

  // Заполняем первый селектор
  $('com_home_span').add('select', {'id':'com_home'}).$('change', inputHandler);
  addOption('com_home', [{'value':'null', 'innerHTML':'Выберите команду&nbsp;&nbsp;'}]);
  var cn = 0;
  for(var i in list) {
    if(i=='service' || i=='extra') continue;
    addOption('com_home', [{'value':i, 'innerHTML':i + '&nbsp;&nbsp;'}]);
    cn++;
  }
  if(isGroups) addOption('com_home', [{'value':'add', 'class':'shl', 'innerHTML':'Новая команда&nbsp;&nbsp;'}]);
  $('com_home').selectedIndex = backup.home;

  // Клонируем второй
  var node = $('com_home').cloneNode(true);
  node.setAttribute('id', 'com_guest');
  node.$('change', inputHandler);
  $('com_guest_span').appendChild(node);
  $('com_guest').selectedIndex = backup.guest;

  // Сбрасываем экстра-блок, только если функцию вызвал не extraHandler()
  if(!isGroups) {
    if(!ehCall) {
      if($isResults && $('extra').checked) {
        $('extra').checked = false;
        $('extra_ps').checked = false;
        $('extra_ps_span').show();
        extraHandler('extra');
      }
    }

    $total[0] = $transitional_russian_champ_mod ? 44 : (cn * $ratio - $ratio); // обновляем число игр в группе, чтобы проверки были корректны
    if($isResults) {
      var sel = $('input_tour'), esel = $('extra_group');
      if(parseInt(selOption(sel), 10)>$total[0]) sel.selectedIndex = 0;
      if(parseInt(selOption(esel), 10)>$total[0] && parseInt(selOption(esel), 10)<=$total[1]) esel.selectedIndex = 0;
    }
  }
}

/* Создание списка ввода бомбардиров и обработка смены его селекторов */
function createBombsList() {
  var list = {}, cn = 1, hv = parseInt($('count_home').value, 10), gv = parseInt($('count_guest').value, 10),
      hs = selOption('com_home') == 'add' ? $('com_home_inp').value : selOption('com_home'),
      gs = selOption('com_guest') == 'add' ? $('com_guest_inp').value : selOption('com_guest');

  // Очищаем и подготавливаем блок бомбардиров
  $('bombs_input').empty(true, true);
  if(hv + gv <= 0) return null;
  $('bombs_input').add('div', {'class':'m5 bb', 'innerHTML':'Голы забили:'});
  $('bombs_input').add('ol', {'id':'bombs_list'});

  // Добавляем элементы списка
  for(var i=0,l=hv+gv; i<l; i++) {
    list[cn] = (i < hv) ? hs : gs;
    cn++;
  }

  for(var i in list) {
    var sn = (list[i] == hs) ? 0 : 1, cid = 'bombs_comms_' + i, pid = 'bombs_players_' + i;
    $('bombs_list').add('li', null, [
      add('div', {'class':'m5'}, [
        add('select', {'id':pid}).$('change',
          function(e) {
            // Обработчик выбора ввода нового игрока
            var slc = e.target || e.srcElement;
            if(selOption(slc)=='add') {
              var inp = $(slc.id + '_inp');
              $(slc).hide();
              inp.show();
              try { inp.focus(); } catch(err) {};
            }
          }),
        add('input', {'type':'text', 'size':'30', 'id':pid + '_inp'}).hide().$(suilib.client.opera ? 'keypress' : 'keyup',
          function(e) {
            // Отмена ввода нового игрока по нажатию ESC
            var inp = e.target || e.srcElement;
            if(e.keyCode==27 && inp.previousSibling && inp.previousSibling.options.length!=0) {
              $(inp.previousSibling).show();
              $(inp).hide();
            }
          })
      ]),
      add('div', {'class':'m10', 'innerHTML':'из команды&nbsp;&nbsp;'}, [add('select', {'id':cid}).$('change',
        function(e) {
          // Перезаполняем селектор при смене команды
          var sid = (e.target || e.srcElement).id;
          var bid = 'bombs_players_' + sid.match(/(\d+)$/g)[0], pid = $('bombs_penalty_' + sid.match(/(\d+)$/g)[0]), aid = $('bombs_auto_' + sid.match(/(\d+)$/g)[0]);

          while($(bid).options.length) $(bid).remove($(bid).options.length - 1);
          insertBombs(bid, selOption(sid));
          if(aid.style.display=='none') {
            aid.show();
            if(pid.checked) pid.checked = false;
            setDisabled(pid, true);
          } else {
            aid.hide();
            setDisabled(pid, false);
          }
        })
      ]),
      $isResults ?
      add('div', {'class':'m10', 'innerHTML':'на&nbsp;&nbsp;'}, [
        add('input', {'type':'text', 'size':'2', 'id':'bombs_time_' + i}),
        add('span', {'innerHTML':'&nbsp;&nbsp;минуте'})
      ]) : null,
      add('div', {'class':'m5'}, [
        add('input', {'type':'checkbox', 'class':'chk', 'id':'bombs_penalty_' + i}),
        add('label', {'for':'bombs_penalty_' + i, 'innerHTML':'с пенальти'}),
        add('span', {'id':'bombs_auto_' + i}, [
          add('input', {'type':'checkbox', 'disabled':'disabled', 'checked':'checked', 'class':'chk', 'style':'margin-left:15px'}),
          add('label', {'class':'red', 'innerHTML':'в свои ворота'})
        ]).hide()
      ])
    ]);

    addOption(cid, [
      {'value':hs, 'innerHTML':hs + '&nbsp;&nbsp;'},
      {'value':gs, 'innerHTML':gs + '&nbsp;&nbsp;'}
    ]);
    $(cid).selectedIndex = sn;

    insertBombs(pid, list[i]);
  }
}

/* Заполняет селектор сохраненными бомбардирами нужной команды */
function insertBombs(sid, com) {
  var arr = getComData(com);
  var bombs = arr ? arr[5] : {},
      names = [], isAG = false;

  $(sid).show();
  $(sid + '_inp').hide();

  // Добавляем в массив фамилии бомбардиров команды
  for(var i in bombs) {
    if(typeof bombs[i][1]=='string' || i.match(/\-$/i)) continue;
    names.push(i);
  }

  // Добавляем в массив фамилии авторов автоголов команды
  $($autogoals).walkwith(function(el) {
    if(el[2].find(com.toString()) && !el[0].match(/\-$/i)) {
      isAG = true;
      names.push(el[0]);
    }
  });

  // Удаляем возможные дубликаты и сортируем фамилии, если для команды были найдены авторы автоголов
  if(isAG) {
    var tmp = {};
    for(var j=0; j<names.length; j++ ) {
      if(tmp[names[j]]==null) tmp[names[j]] = j;
      else {
        names.splice(j, 1);
        j--;
      }
    }
    names.sort();
  }

  // Заполняем селектор опциями
  $(names).walkwith(function(el) {
    addOption(sid, [{'value':el, 'innerHTML':el}]);
  });
  if(names.length!=0) addOption(sid, [{'value':'add', 'class':'shl', 'innerHTML':'Новый игрок&nbsp;&nbsp;'}]);

  // Скрываем селектор, если нет бомбардиров, авторов автоголов или сохранены только авторы автоголов из других команд
  if(names.length==0) {
    $(sid).hide();
    $(sid + '_inp').show();
  }
}

/* Модицифированный объект "Динамические вкладки" (оригинал портирован из SUILib v1.3.x) */
var tabs = {
  init: function(args) {
    if(!args.apply) return false;
    var allNodes = args.apply.length ? $(suilib.body).filter('*',null,null,true) : [];
    var len = allNodes.length;
    for(var i=0,l=args.apply.length; i<l; i++) {
      this.all[i] = {};
      if(!args.apply[i].els && !args.apply[i].hds) continue;
      if(typeof args.apply[i].els=='string') {
        var tmp = [];
        for(var j=0; j<len; j++)
          if(allNodes[j] && allNodes[j].className && allNodes[j].className.split(' ').hasa(args.apply[i].els)!==false)
            tmp.push(allNodes[j]);
        this.all[i].els = tmp;
      } else if(typeof args.apply[i].els=='object' && args.apply[i].els.length)
        this.all[i].els = args.apply[i].els;
      if(args.apply[i].hds) {
        if(typeof args.apply[i].hds=='string') {
          var tmp = [];
          for(var j=0; j<len; j++)
            if(allNodes[j] && allNodes[j].className && allNodes[j].className.split(' ').hasa(args.apply[i].hds)!==false)
              tmp.push(allNodes[j]);
          this.all[i].hds = tmp;
        } else if(typeof args.apply[i].hds=='object' && args.apply[i].hds.length)
          this.all[i].hds = args.apply[i].hds;
      }
      if(args.apply[i].open) {
        var what = this.all[i].els ? this.all[i].els : this.all[i].hds;
        if(typeof args.apply[i].open=='string')
          this.all[i].open = $(args.apply[i].open);
        else if(typeof args.apply[i].open=='number' && args.apply[i].open<=what.length)
          this.all[i].open = $(what[args.apply[i].open-1]);
      }
      this.all[i].callback = args.apply[i].callback || suilib.anonymous;
      this.buildTabs(this.all[i]);
    }
  },

  all: [],
  cls: ['tab', 'tab_act', 'tab_hover'],

  buildTabs: function(tArr) {
    var tHd = [], len = tArr.els ? tArr.els.length : tArr.hds.length;
    for(var i=0; i<len; i++) {
      var el = tArr.els ? $(tArr.els[i]) : null, hd = false;
      if(tArr.hds) hd = $(tArr.hds[i]); else {
        hd = el.filter('*',null,null,true)[0];
        el.parentNode.insertBefore(hd, $(tArr.els[0]));
        tHd.push(hd);
      }
      if(tArr.open && el==tArr.open) tArr.open = hd;
      if(el) el.hide();
    }
    if(!tArr.hds) tArr.hds = tHd;

    var handlerClick = [], handlerOver = [], handlerOut = [];
    for(var i=0,l=tArr.hds.length; i<l; i++) {
      handlerClick[i] = (function(){tabs.openTab(tArr, arguments.callee.obj);});
      handlerOver[i]  = (function(){var el = arguments.callee.obj, allCls = (el.className.split(' ') || []); if(allCls.hasa(tabs.cls[1])===false) el.classReplace('tab_hover', tabs.cls);});
      handlerOut[i]   = (function(){var el = arguments.callee.obj, allCls = (el.className.split(' ') || []); if(allCls.hasa(tabs.cls[1])===false) el.classReplace('tab', tabs.cls);});
      handlerClick[i].obj = handlerOver[i].obj = handlerOut[i].obj = tArr.hds[i];
      handlerClick[i].$('click', tArr.hds[i]);
      handlerOver[i].$('mouseover', tArr.hds[i]);
      handlerOut[i].$('mouseout', tArr.hds[i]);
    }

    this.openTab(tArr, tArr.open ? tArr.open : tArr.hds[0]);
  },

  openTab: function(tArr, tOpen) {
    var index = 0, tHd = tArr.hds;
    for(var i=0,l=tHd.length; i<l; i++) {
      var allCls = (tHd[i].className.split(' ') || []);
      if(tHd[i]==tOpen) {
        if(allCls.hasa(tabs.cls[1])!==false) return false;
        tHd[i].classReplace('tab_act', this.cls);
        index = i;
      } else {
        if(allCls.hasa(tabs.cls[0])!==false) continue;
        tHd[i].classReplace('tab', this.cls);
        if(tArr.els) $(tArr.els[i]).hide();
      }
    }
    var el = tArr.els ? tArr.els[index] : null;
    if(tArr.callback) tArr.callback(tHd[index], el, index+1);
    if(el) $(tArr.els[index]).show();
  }
};

/* Объект для работы с хэшами */
var objTools = {
  print: function(hash) {
    if(!hash || typeof(hash)!=='object') return null;
    return 'var data = ' + this.parse(hash) + ';';
  },
  $specialChars: {
    '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"': '\\"', '\\': '\\\\'
  },
  $replaceChars: function(chr) {
    return this.$specialChars[chr] || '\\u00' + Math.floor(chr.charCodeAt() / 16).toString(16) + (chr.charCodeAt() % 16).toString(16);
  },
  parse: function(hash) {
    var self = this;
    switch(typeof(hash)) {
      case 'string':
        return "\"" + hash.replace(/[\x00-\x1f\\"]/g, function(chr){ return self.$replaceChars.apply(self, [chr]); }) + "\"";
      case 'number':
        return isFinite(hash) ? String(hash) : 'null';
      case 'object':
        if(hash===null) return String(hash);
        var string = [];
        if('length' in hash) {
          for(var i=0,l=hash.length; i<l; i++) {
            if(typeof hash[i]=='undefined') continue;
            string.push(this.parse(hash[i]));
          }
          return '[' + String(string) + ']';
          break;
        }
        for(var i in hash) {
          var json = this.parse(hash[i]);
          if(json) string.push(this.parse(i) + ':' + json);
        }
        return '{' + string + '}';
      default: return String(hash);
    }
    return null;
  },
  length: function(hash, exclude) {
    if(!hash || typeof(hash)!=='object') return null;
    var len = false;
    for(var key in hash) {
      if(exclude && exclude.length && exclude.hasa(key)!==false) continue;
      len++;
    }
    return len;
  },
  clone: function(hash) {
    if(!hash || typeof(hash)!=='object') return hash;
    var newHash = hash.constructor();
    for(var key in hash)
      newHash[key] = this.clone(hash[key]);
    return newHash;
  },
  hash: function(arr) {
    if(!arr || !(arr instanceof Array)) return arr;
    if(arr.length==0) return {};
    var hash = {};
    for(var i=0,l=arr.length; i<l; i++)
      hash[i] = arr[i];
    return hash;
  },
  array: function(hash, onlyKeys, exclude) {
    if(!hash || typeof(hash)!=='object') return hash;
    if(!this.length(hash)) return [];
    var arr = [];
    for(var key in hash) {
      if(exclude && exclude.length && exclude.hasa(key)!==false) continue;
      arr.push(key);
      if(!onlyKeys) arr.push(hash[key]);
    }
    return arr;
  },
  key: function(hash) {
    if(!hash || typeof(hash)!=='object') return null;
    for(var key in hash)
      break;
    return key;
  },
  lastKey: function(hash) {
    if(!hash || typeof(hash)!=='object') return null;
    for(var key in hash);
    return key;
  },
  extend: function(hash, source_hash) {
    if(!hash || typeof(hash)!=='object') return null;
    for(var key in source_hash) hash[key] = source_hash[key];
    return hash;
  }
};


/*** Обработчики ***/

/*
  Глобальный универсальный обработчик элементов блока ввода данных
  АЛАРМ! На функцию много ссылок - с поправками лезть аккуратно
*/
function inputHandler(e) {
  var el = e.target || e.srcElement || $(e), isSel = !!(el.tagName === 'SELECT'), btn = $('match_add');
  var val = selOption(isSel ? el : 'com_home'),
      another = selOption(isSel ? (el.id == 'com_home' ? 'com_guest' : 'com_home') : 'com_guest');
  var hc = parseInt($('count_home').value, 10), gc = parseInt($('count_guest').value, 10),
      hps = parseInt($('count_home_ps').value, 10), gps = parseInt($('count_guest_ps').value, 10),
      tech = $('tech').checked;

  if(isSel && val!='add' && val==another) { // защита от дурака о_О
    if(!btn.disabled) {
      btn.disabled = true;
      $('bombs_input').empty(true, true);
    }
    el.selectedIndex = 0;
    return false;
  }

  // Переключаемся на ввод новой команды
  if(isSel && val=='add') {
    var inp = $(el.id + '_inp');
    $(el).hide();
    inp.show(); inp.value = '';
    try { inp.focus(); } catch(err) {};
  }

  // Удаляем блок ввода бомбардиров при включении режима "техническое поражение"
  if(tech) $('bombs_input').empty(true, true);

  btn.disabled = true;

  // Все проверки (если прошли - то включаем кнопку "Добавить матч" и пробуем создать блок ввода бомбардиров)
  if(val=='null' || another=='null' || isNaN(hc) || isNaN(gc) || hc < 0 || gc < 0) return false;
  if($isResults && $('extra_ps').checked && (isNaN(hps) || isNaN(gps) || hps < 0 || gps < 0 || hps==gps)) return false;
  if(selOption('com_home')=='add' && ($('com_home_inp').style.display=='none' || $('com_home_inp').value=='')) return false;
  if(selOption('com_guest')=='add' && ($('com_guest_inp').style.display=='none' || $('com_guest_inp').value=='')) return false;
  if(tech && hc==gc) return false;
  btn.disabled = false;
  if(el.id!='count_home_ps' && el.id!='count_guest_ps' && !tech) createBombsList();
}

/*
  Глобальный обработчик активации/деактивации блока дополнительного матча
  АЛАРМ! На функцию много ссылок - с поправками лезть аккуратно
*/
function extraHandler(e) {
  var chk = e.target || e.srcElement || $(e), active = chk.checked, ch = 'com_home', cg = 'com_guest',
      eg = 'extra_group_div', ep = 'extra_ps', eps = 'extra_ps_span', epsd = 'extra_ps_div',
      tech = $('tech').checked,
      extra_group = (selOption('extra_group') == 'add' && $('extra_group_inp').style.display != 'none') || (selOption('extra_group') != 'add' && matchType(selOption('extra_group')));

  setDisabled(ep, (extra_group ? false : true) || tech);
  $(ep).checked = false;
  if(!extra_group || tech) $(epsd).hide();
  $('input_tour').disabled = active ? true : false;

  var createNC = function(action) { // добавляет или удаляет в селекторах опцию "Новая команда"
    if(!document.getElementById(ch)) return false;

    var nc = 'Новая команда',
        lastItem = $(ch)[$(ch).options.length - 1].html().replace(/\&nbsp;|\s+$/g, '');
    if(action && lastItem!=nc) {
      var opts = [{'value':'add', 'class':'shl', 'innerHTML':nc+'&nbsp;&nbsp;'}];
      addOption(ch, opts); addOption(cg, opts);
    }
    else if(!action && lastItem==nc) {
      $(ch).remove($(ch).options.length - 1);
      $(cg).remove($(cg).options.length - 1);
    }
  };
  var modifyComs = function(action) { // включает или отключает селектор выбора группы и перезаполняет селекторы выбора команд
    if($isGroups) {
      if(action) {
        $isGroups.disabled = true;

        var temp = {}, all = {}, keys = [];
        for(var i in data[$key]) if(i!='service' && i!='extra') temp = objTools.extend(temp, data[$key][i]);
        keys = objTools.array(temp, true);
        keys.sort();
        for(var i=0,l=keys.length; i<l; i++) all[keys[i]] = temp[keys[i]];

        createComsSelectors(all, true);
      } else {
        $isGroups.disabled = false;

        var grn = selOption($isGroups, true);
        createComsSelectors(data[$key][grn.replace(/\&nbsp;|\s+$/g, '')], false, true);
      }
    }
    inputHandler('com_home');
  };
  createNC(extra_group);

  if(active) {
    modifyComs(extra_group);

    if($(eps).style.display!='none') return null;
    $(eg).animate(.35, {height:[0, 35]}, function() {
      createNC(extra_group);
      $(eps).show();
    });
  } else {
    if($(eps).style.display=='none') return null;

    $(eg).animate(.35, {height:[35, 0]}, function() {
      modifyComs(false);
      createNC(false);
      $(eps).hide(); $(epsd).hide();

      var backup = function(sid) {
        $(sid).show();
        $(sid + '_inp').hide();
      };
      backup(ch); backup(cg);
      inputHandler(ch);
    });
  }
}

/* DOMContentLoaded */
suilib.ready(function() {
  pagePrepare();

  // Скрытие/раскрытие левого блока
  (function(e) {
    var left = $('menu'), main = $('main'), btn = e.target || e.srcElement;
    if(btn.className=='toggler') {
      left.animate(.5, {width:[315, 5]}, function() {
        main.classAdd('readonly');
        btn.classAdd('open');
      });
    } else {
      left.animate(.5, {width:[5, 315]}, function() {
        main.classRemove('readonly');
        btn.classRemove('open');
      });
    }
  }).$('click', 'toggler');

  // Печать статистики
  (function(e) {
    e.returnValue = false;
    if(e.preventDefault) e.preventDefault();

    window.print();
  }).$('click', 'r_print', 't_print');

  // Создаем турнир(ы)
  (function() {
    if(objTools.length(data)) pagePrepare(); else alert('Запуск невозможен: не создан ни один турнир!');
  }).$('click', 'sys_load');
  (function() {
    var ol = objTools.length(data);
    if(ol) {
      if(confirm('Создано: '+ol+' турнир(ов). Вы действительно хотите сбросить их?')) {
        data = {};
        alert('Все данные удалены: можно начинать сначала!');
      }
    } else alert('Действие невозможно: данные не созданы или уже были удалены!');
  }).$('click', 'data_reset');
  (function(e) {
    var name = $('trn_name').value.trim(), inp = e.target || e.srcElement;
    var groups = $('groups').filter('div', 'commands_container', null, true);

    var saveGroup = function(gn) { // возвращает хэш данных одной группы для сохранения
      var coms = [], hash = {};
      $(groups)[gn].filter('input', null, {'type':'text'}, true).walkwith(function(el) {
        var val = el.value;
        if(val) coms.push(val.trim());
      });

      if(coms.length < 2) {
        alert('Для сохранения необходимо назвать все команды!');
        delete data[name];
        return false;
      }

      for(var i=0,l=coms.length; i<l; i++) {
        hash[coms[i]] = [0, 0, 0, 0, 0, {}, {}, []];

        if($('champ_'+gn+'_'+i).checked) { // у команды есть статусы?
          hash[coms[i]][7].push('champ');
        }
        if($('cup_'+gn+'_'+i).checked) {
          hash[coms[i]][7].push('cup');
        }
        if($('new_'+gn+'_'+i).checked) {
          hash[coms[i]][7].push('new');
        }
      }

      return hash;
    };

    var org = inp.value;
    inp.value = 'Сохраняем...';
    setTimeout(function(){ inp.value = org; }, 500);

    if(!name) {
      alert('Для сохранения необходимо дать название турниру!');
      return false;
    }
    if(!groups.length) {
      alert('В турнир необходимо добавить хотя бы две команды!');
      return false;
    }
    data[name] = {};
    if(groups.length==1) {
      var hash = saveGroup(0);
      if(!hash) return false;
      data[name] = hash;
    } else {
      for(var i=0; i<groups.length; i++) {
        if(!$('group_'+i).value) {
          alert('Для сохранения необходимо назвать все группы!');
          delete data[name];
          return false;
        }
        var hash = saveGroup(i);
        if(!hash) return false;
        data[name]['Группа ' + $('group_'+i).value.trim()] = hash;
      }
    }

    // Заполняем служебный хэш
    data[name].service = {};
    data[name].service.edited = currentTime();
    data[name].service.results = $('trn_results').checked;
    data[name].service.ratio = parseInt(selOption('trn_ratio'), 10);
    $('zones').filter('input', null, {'type':'checkbox'}, true).walkwith(function(el) { // подсвечивать зоны?
      if(el.checked) {
        var sv = el.id.split('_'),
            txt = $(sv[0]+'_text').value != $alias[sv[0]];
        if(!data[name].service[sv[0]]) {
          data[name].service[sv[0]] = [];
          if(txt) data[name].service[sv[0]].push($(sv[0]+'_text').value.trim());
        }
        data[name].service[sv[0]].push(parseInt(sv[1], 10));
      }
    });
  }).$('click', 'trn_save');
  (function() {
    $('trn').reset();
    $('groups').empty(true, true);
  }).$('click', 'trn_reset');
  (function(e) {
    var num = parseInt($('groups_num').value, 10), cn = parseInt($('commands_num_0').value, 10);
    $('groups').empty(true, true);
    if(isNaN(num) || num < 1 || isNaN(cn) || cn < 2) return false;

    var chkHandler = function(e) { // обработчик чекбоксов подсветок зон
      var chk = e.target || e.srcElement,
          arr = chk.id.split('_'),
          all = ['lch', 'le', 'out'];

      $(all).walkwith(function(el) {
        if(el!=arr[0]) {
          var trg = $(el+'_'+arr[1]);
          trg.checked = false;
          setDisabled(trg, chk.checked);
        }
      });
    };

    var createComs = function(e) { // создаёт команды в группах
      var inp = e.target || e.srcElement || $(e);
      var cn = parseInt(inp.value, 10),
          bn = parseInt(inp.id.match(/(\d+)$/g)[0], 10);

      bn = bn==0 ? 0 : bn - 1;
      var cb = $('commands_'+bn), old_cn = cb.filter('div', 'block', null, true);
      cb.empty(true, true);
      if(isNaN(cn) || cn < 2) cn = old_cn.length;

      // Вычисляем максимальное количество команд во всех группах
      var nums = [];
      $('groups').filter('input', 'commands_nums', null, true).walkwith(function(el) {
        nums.push(el.value);
      });

      var stimg = function(name) { // возвращает картинку с подсказкой для выбора статуса команды
        return [add('img', {'align':'top', 'alt':$alias[name][0], 'title':$alias[name][0], 'style':'padding-right:10px', 'src':$alias[name][1]})];
      };

      $('lch').empty(true, true);
      $('le').empty(true, true);
      $('out').empty(true, true);
      for(var i=0; i<cn; i++) {
        cb.add('div', {'class':'block'}, [
          add('div', {'class':'left', 'style':'width:10px', 'innerHTML':i+1+'. '}),
          add('div', {'class':'nofloat'}, [
            add('div', {'class':'m5'}, [add('input', {'type':'text', 'size':'24'})]),
            // Выбор статуса команды
            add('div', null, [
              add('input', {'type':'checkbox', 'class':'chk', 'id':'champ_'+bn+'_'+i}),
              add('label', {'for':'champ_'+bn+'_'+i}, stimg('champ')),
              add('input', {'type':'checkbox', 'class':'chk', 'id':'cup_'+bn+'_'+i}),
              add('label', {'for':'cup_'+bn+'_'+i}, stimg('cup')),
              add('input', {'type':'checkbox', 'class':'chk', 'id':'new_'+bn+'_'+i}),
              add('label', {'for':'new_'+bn+'_'+i}, stimg('new'))
            ])
          ])
        ]);
      }

      // Создаем панельку выбора подсветки зон для мест в турнирной таблице
      for(var i=0,l=nums.length==0 ? cn : getMax(nums); i<l; i++) {
        $('lch').add('input', {'type':'checkbox', 'class':'chk', 'id':'lch_'+(i+1)}).$('click', chkHandler);
        $('lch').add('label', {'for':'lch_'+(i+1), 'style':'padding-right:10px'}, [addtext(i+1)]);
        $('le').add('input', {'type':'checkbox', 'class':'chk', 'id':'le_'+(i+1)}).$('click', chkHandler);
        $('le').add('label', {'for':'le_'+(i+1), 'style':'padding-right:10px'}, [addtext(i+1)]);
        $('out').add('input', {'type':'checkbox', 'class':'chk', 'id':'out_'+(i+1)}).$('click', chkHandler);
        $('out').add('label', {'for':'out_'+(i+1), 'style':'padding-right:10px'}, [addtext(i+1)]);
      }
    };

    $('groups').add('h3', {'innerHTML':'Структура турнира'});
    $('groups').add('div', {'id':'zones', 'class':'m20'}, [
      add('div', {'class':'m5'}, [
        add('input', {'type':'text', 'size':'30', 'value':$alias.lch, 'id':'lch_text'}),
        add('span', {'style':'padding-left:15px', 'id':'lch'})
      ]),
      add('div', {'class':'m5'}, [
        add('input', {'type':'text', 'size':'30', 'value':$alias.le, 'id':'le_text'}),
        add('span', {'style':'padding-left:15px', 'id':'le'})
      ]),
      add('div', {'class':'m5'}, [
        add('input', {'type':'text', 'size':'30', 'value':$alias.out, 'id':'out_text'}),
        add('span', {'style':'padding-left:15px', 'id':'out'})
      ])
    ]);
    $('groups').add('div', {'class':'hr m20', 'style':'clear:both', 'innerHTML':'&nbsp;'});
    for(var i=0; i<num; i++) {
      $('groups').add('div', {'class':'nofloat m20'}, [
        num!=1 ? add('div', {'class':'m10'}, [
          add('b', {'innerHTML':'Группа:'}),
          add('input', {'type':'text', 'size':'2', 'style':'margin-left:7px', 'id':'group_'+i}),
          add('span', {'innerHTML':'&nbsp;&nbsp;c&nbsp;&nbsp;'}),
          add('input', {'type':'text', 'size':'2', 'value':cn, 'class':'commands_nums', 'id':'commands_num_'+(i+1)}).$('keyup', createComs),
          add('span', {'innerHTML':'&nbsp;&nbsp;командами'}),
        ]) : null,
        add('div', {'id':'commands_'+i, 'class':'commands_container'})
      ]);

      createComs(num!=1 ? 'commands_num_'+(i+1) : 'commands_num_0');
      if(i!=num-1) $('groups').add('div', {'class':'hr m20', 'style':'clear:both', 'innerHTML':'&nbsp;'});
    }
  }).$('click', 'groups_add');

  // Смена сортировки таблицы результатов
  (function(e) {
    $url.tour[1] = parseInt((e.target || e.srcElement).value, 10);
    navi(true);
    createResults($url.tour[0]);
  }).$('change', 'r_types');

  // Смена типов и сортировок таблицы бомбардиров
  (function(e) {
    var type = parseInt((e.target || e.srcElement).value, 10), sorting = parseInt(selOption('b_sorts'), 10);
    createBombers(type, sorting);
  }).$('change', 'b_types');
  (function(e) {
    var type = parseInt(selOption('b_types'), 10), sorting = parseInt((e.target || e.srcElement).value, 10);
    createBombers(type, sorting);
  }).$('change', 'b_sorts');

  // Ввод данных
  (function(e) {
    var el = e.target || e.srcElement;
    if(parseInt(el.value, 10)==0) el.value = '';
  }).$('focus', 'count_home', 'count_guest', 'count_home_ps', 'count_guest_ps', 'correct_num');
  (function(e) {
    var el = e.target || e.srcElement;
    if(!el.value) el.value = 0;
  }).$('blur', 'count_home', 'count_guest', 'count_home_ps', 'count_guest_ps', 'correct_num');
  inputHandler.$('keyup', 'count_home', 'count_guest', 'count_home_ps', 'count_guest_ps');
  if(objTools.length(data)) inputHandler.$('change', 'com_home', 'com_guest');

  // Включение/выключение серии пенальти
  (function(e) {
    var chk = e.target || e.srcElement, epsc = $('extra_ps_div');
    if(chk.checked) {
      epsc.show();
      try { $('count_home_ps').focus(); } catch(err) {};
    } else epsc.hide();
    inputHandler('count_home_ps');
  }).$('click', 'extra_ps');

  // Отмена ввода новой команды и новой стадии
  (function(e) {
    var inp = e.target || e.srcElement, egi = (inp.id == 'extra_group_inp');
    if(e.keyCode==27) {
      var selector = egi ? inp.previousSibling : inp.previousSibling.firstChild;
      $(selector).show();
      $(inp).hide();
      if(egi) extraHandler('extra');
    }
    if(!egi) inputHandler(e);
  }).$(suilib.client.opera ? 'keypress' : 'keyup', 'com_home_inp', 'com_guest_inp', 'extra_group_inp');

  // Включение/выключение режима "техническое поражение"
  (function(e) {
    if($isResults && $('extra').checked) extraHandler('extra'); else inputHandler(e);
  }).$('click', 'tech');

  // Включение/выключение дополнительного матча
  extraHandler.$('click', 'extra');

  // Добавляем матч
  (function(e) {
    var hv = parseInt($('count_home').value, 10), gv = parseInt($('count_guest').value, 10),
        hs = selOption('com_home') == 'add' ? $('com_home_inp').value.trim() : selOption('com_home'),
        gs = selOption('com_guest') == 'add' ? $('com_guest_inp').value.trim() : selOption('com_guest'),
        tech = $('tech').checked;
    if($isResults) var mn = selOption('input_tour'), hcb = {}, gcb = {},
                       extra = $('extra').checked, extra_ps = $('extra_ps').checked,
                       extra_group = selOption('extra_group') == 'add' ? $('extra_group_inp').value.trim() : selOption('extra_group'),
                       hps = parseInt($('count_home_ps').value, 10), gps = parseInt($('count_guest_ps').value, 10);

    var arr = function(c) { // обёртка для функции getComData
      return getComData(c);
    };

    if(extra && (extra_group=='add' || extra_group=='')) { // защита от дурака О_о
      alert('Необходимо ввести названия стадии!');
      return false;
    }
    if(!extra && ((arr(hs)[0]+arr(hs)[1]+arr(hs)[2])>=$total[0] || (arr(gs)[0]+arr(gs)[1]+arr(gs)[2])>=$total[0])) { // защита от второго дурака o_О
      alert('Все матчи одной или обеих команд уже были сыграны!');
      return false;
    }
    if(!extra && arr(hs)[6][mn]) { // защита от третьего дурака O_O
      alert('Извините, но в этом туре матч с такой командой-хозяином уже был сыгран: вы можете исправить результат, включив в блоке ввода дополнительный матч!');
      return false;
    }

    // Проверяем заполнены ли все поля ввода новых бомбардиров
    var isBombs = (hv + gv == 0) ? false : true,
        isEmpty = false,
        all = $('bombs_input').filter('li', null, null, true),
        names = [], times = [], pnls = [], autos = [], coms = [];

    if(isBombs) {
      $(all).walkwith(function(el) {
        var childs = $(el).filter('div', null, null, true);
        var name = (childs[0].firstChild.style.display == 'none') ? childs[0].firstChild.nextSibling.value.trim() : selOption(childs[0].firstChild),
            time = $isResults ? $(childs[2]).filter('input', null, null, true)[0].value : '1'; // назначаем корректную "пустышку", если сохранение результатов отключено
        if(name=='' || name=='add' || time=='' || isNaN(parseInt(time, 10)) || parseInt(time, 10)<=0) isEmpty = true;
        names.push(name);
        times.push(time);
        pnls.push(childs[$isResults ? 3 : 2].firstChild.checked);
        autos.push($(childs[$isResults ? 3 : 2]).filter('span', null, null, true)[0].style.display == 'none' ? false : true);
        coms.push(selOption($(childs[1]).filter('select', null, null, true)[0]));
      });
      if(isEmpty) { // защита от четвёртого дурака O_О O_О
        alert('Необходимо корректно заполнить все поля в блоке ввода бомбардиров!');
        return false;
      }
    }

    // Получаем номер и полное название (только для допстадий) тура для записи
    var st_num = false;
    if(extra && matchType(extra_group)) {
      var st_name = '';

      if($extra_names[extra_group]) {
        st_num = extra_group;
        st_name = extra_group + '|' + $extra_names[extra_group];
      } else {
        var keys = [];
        for(var i in $extra_names) keys.push(parseInt(i, 10));
        var minV = getMin(keys), maxV = getMax(keys);
        st_num = $total[2] ? ((isFinite(minV) && minV < 0) ? (minV - 1) : -1) : ((isFinite(maxV) && maxV > $total[1]) ? (maxV + 1) : $total[1] + 1);
        st_name = st_num + '|' + extra_group;
      }
    } else {
      st_num = extra && !matchType(extra_group) ? extra_group : mn;
    }


    // Удаляем нужный матч вместе с результатами
    var backup = [];
    var deleteInBombs = function(str, com) { // удаляет статистику бомбардиров
      if(!str || !arr(com)) return false;

      var hb = str.split(',');
      for(var i=0,l=hb.length; i<l; i++) {
        var all = hb[i].split('^');
        if(!arr(com)[5][all[0]]) continue;

        for(var j=1,k=all.length; j<k; j++) {
          arr(com)[5][all[0]][0]--;
          if(all[j].find('%')) arr(com)[5][all[0]][1]--;
        }
        if(arr(com)[5][all[0]][0]==0) delete arr(com)[5][all[0]];
      }
    };

    // Если добавляется переигровка
    if(extra && !matchType(extra_group)) {
      if(!arr(hs)[6][extra_group]) { // еще защита O_О
        alert('Матч, который Вы хотите изменить, не был сыгран: пожалуйста, воспользуйтесь обычным способом добавления!');
        return false;
      }

      var mtch = arr(hs)[6][extra_group].split('|'), rm = getCount(mtch[1], mtch[2]);

      if(tech && mtch[4]) { // и еще одна, вроде последняя, защита OО_ОО
        alert('В этом матче одной из команд уже было засчитано техническое поражение!');
        return false;
      }

      // Бэкапим результаты при "техническом поражении"
      if(tech) {
        backup.push(mtch[1] || '');
        backup.push(mtch[2] || '');
      }

      // Удаляем статистику матча
      if(rm[0]>rm[1]) {
        arr(hs)[0]--; arr(gs)[2]--;
      } else if(rm[0]==rm[1]) {
        arr(hs)[1]--; arr(gs)[1]--;
      } else {
        arr(gs)[0]--; arr(hs)[2]--;
      }
      arr(hs)[3] -= rm[0]; arr(hs)[4] -= rm[1];
      arr(gs)[3] -= rm[1]; arr(gs)[4] -= rm[0];

      deleteInBombs(mtch[1], hs); deleteInBombs(mtch[2], gs);

      // Удаляем результат
      arr(hs)[6][extra_group] = '';
    }

    // Если добавляется матч, уже сохранённый в выбранной допстадии
    if(extra && matchType(extra_group) && data[$key].extra) {
      var extra_hash = data[$key].extra;
      for(var i in extra_hash) {
        for(var j=0,l=extra_hash[i].length; j<l; j++) {
          var res_str = extra_hash[i][j];
          if(res_str.find(hs) && res_str.find(gs)) {
            var res = res_str.split('|');
            if(res[0]!=hs) continue;

            // Бэкапим результаты при "техническом поражении"
            if(tech) {
              backup.push(res[2] || '');
              backup.push(res[3] || '');
              backup.push(res[4] || '');
            }

            if(st_num > $total[1]) {
              deleteInBombs(res[2], hs);
              deleteInBombs(res[3], gs);
            }
          }
        }
      }
    }


    // Сохраняем победы-ничьи-поражения и разницу мячей
    if(!extra || (extra && !matchType(extra_group))) {
      if(hv>gv) {
        arr(hs)[0]++; arr(gs)[2]++;
      } else if(hv==gv) {
        arr(hs)[1]++; arr(gs)[1]++;
      } else {
        arr(gs)[0]++; arr(hs)[2]++;
      }
      arr(hs)[3] += hv; arr(hs)[4] += gv;
      arr(gs)[3] += gv; arr(gs)[4] += hv;
    }

    if(isBombs) {
      for(var i=0,l=all.length; i<l; i++) {
        // Сохраняем бомбардиров
        var rc = autos[i] ? (coms[i] == hs ? gs : hs) : coms[i];

        if(arr(rc) && (!extra || (extra && (st_num > $total[1])))) {
          if(!arr(rc)[5][names[i]]) arr(rc)[5][names[i]] = [0, 0];
          arr(rc)[5][names[i]][0]++;
          if(pnls[i]) arr(rc)[5][names[i]][1]++;
          if(autos[i]) {
            if(arr(rc)[5][names[i]][1]==0) arr(rc)[5][names[i]][1] = coms[i]; else
              if(!arr(rc)[5][names[i]][1].find(coms[i])) arr(rc)[5][names[i]][1] = arr(rc)[5][names[i]][1] + ', ' + coms[i];
          }
        }

        // Готовим хэш для сохранения результатов
        if($isResults) {
          var hash = rc==hs ? hcb : gcb, name = names[i].trim().replace(/\*|\-$/, '');
          if(!hash[name]) hash[name] = '';
          hash[name] += '^' + times[i] + (pnls[i] ? '%' : '') + (autos[i] ? '@' : '');
        }
      }
    }

    // Сохраняем результаты
    if($isResults) {
      var harr = [], garr = [];
      for(var i in hcb) harr.push(i + hcb[i]);
      for(var i in gcb) garr.push(i + gcb[i]);

      if(backup.length) { // возвращаем результат матча, если ему позже засчитали "техническое поражение"
        harr = backup[0]; garr = backup[1];
        extra_ps = (backup[2] && backup[2].find(':')) ? backup[2].split(':') : false; // перезапишем статус чекбокса, чтобы корректно пройти проверки
        if(extra_ps) {
          hps = ps[0]; gps = ps[1];
        }
      }

      var str = gs
                + (harr.length ? ('|' + (typeof(harr)=='string' ? harr : harr.join(','))) : (garr.length || extra_ps || tech ? '|' : ''))
                + (garr.length ? ('|' + (typeof(garr)=='string' ? garr : garr.join(','))) : (extra_ps || tech ? '|' : ''))
                + (extra_ps ? ('|' + hps + ':' + gps) : (tech ? '|' : ''))
                + (tech ? ('|' + hv + ':' + gv) : '');

      // Добавляем результат матча в допстадию (перезаписывая старый результат, если он там уже был)
      if(extra && matchType(extra_group)) {
        var newArr = [], duplicate = false;
        if(!data[$key].extra) data[$key].extra = {};
        if(!data[$key].extra[st_name]) {
          data[$key].extra[st_name] = [];
        } else {
          for(var i=0,l=data[$key].extra[st_name].length; i<l; i++) {
            var res_str = data[$key].extra[st_name][i], res = '';
            if(res_str.find(hs) && res_str.find(gs) && res_str.split('|')[0]==hs) {
              duplicate = true;
              res = hs + '|' + str;
            } else {
              res = res_str;
            }
            newArr.push(res);
          }
        }
        if(!duplicate) newArr.push(hs + '|' + str);
        data[$key].extra[st_name] = newArr;
      // Либо просто записываем его в тур
      } else {
        arr(hs)[6][st_num] = str;
      }
    }

    // Сохраняем время редактирования и перегружаем страницу
    data[$key].service.edited = currentTime();
    loadData(parseInt(st_num, 10));
  }).$('click', 'match_add');

  // Выводим окно для ручной коррекции очков
  (function(e) {
    var tid = 'popup_correct';

    openModal(tid);
    document.body.setAttribute('rel', tid);

    // Получаем все команды и сортируем их по алфавиту, если турнир мультигрупповой
    var temp = {}, all = {}, keys = [];
    for(var i in data[$key]) if(i!='service' && i!='extra') {
      if('length' in data[$key][i]) {
        all[i] = data[$key][i];
      } else {
        temp = objTools.extend(temp, data[$key][i]);
      }
    }
    if(!objTools.length(all)) {
      keys = objTools.array(temp, true);
      keys.sort();
      for(var i=0,l=keys.length; i<l; i++) all[keys[i]] = temp[keys[i]];
    }

    // Создаём селектор и заполняем его командами
    $('correct_commands_span').empty(true, true);
    $('correct_commands_span').add('select', {'id':'correct_commands'});
    var cn = 0;
    for(var i in all) {
      addOption('correct_commands', [{'value':i, 'innerHTML':i + '&nbsp;&nbsp;'}]);
      cn++;
    }

    // Вешаем обработчики
    if(!$(tid).getAttribute('rel')) {
      $(tid).setAttribute('rel', 'wasOpened');
      (function() {
        var arr = getComData(selOption($('correct_commands')), true),
            cn  = parseInt(selOption($('correct_sign')) + $('correct_num').value.trim(), 10);

        if(cn==0) { // на всякий случай :)
          alert('Корректирующее число не может быть нулём!');
          return false;
        }

        $(tid).hide();
        $('overlay').hide();
        if(!arr[8]) arr[8] = 0;
        arr[8] += cn;
        data[$key].service.edited = currentTime();
        loadData();
      }).$('click', 'correct_apply');
    }
  }).$('click', 'correct_points');

  // Выводим окно с данными для ручного сохранения
  (function(e) {
    var tid = 'popup_data_save',
        ts = function() {
               $('data_save_text').select();
             };

    openModal(tid);
    document.body.setAttribute('rel', tid);

    // Выводим данные
    $('data_save_text').value = objTools.print(data);
    setTimeout(ts, 600);

    // Вешаем обработчики
    if(!$(tid).getAttribute('rel')) {
      $(tid).setAttribute('rel', 'wasOpened');
      ts.$('click', 'data_save_text');
      (function() {
        document.location.reload(true);
      }).$('click', 'data_save_refresh');
    }
  }).$('click', 'data_save');
});


/* Эмблемы (начало вставки) */
var emblems = {};
/* Эмблемы (конец вставки) */


/* Все данные (начало вставки) */
var data = {};
/* Все данные (конец вставки) */
//]]>
</script>

</body>
</html>