<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Author" content="Craigy (grinder@uic.tula.ru)" />
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=windows-1251" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8" />
<title>Система футбольной статистики (v3.0)</title>
<style type="text/css" media="screen">
html, body {
  height: 100%; }
body {
  position: relative;
  background: #F3F3F3;
  color: #333333;
  font: 11px Arial, Verdana, Helvetica, sans-serif;
  line-height: 130%; }
* {
  padding: 0;
  margin: 0; }
a, .blue {
  color: #436976; }
a img, table {
  border: 0; }
a:focus {
  outline: none; }
.z {
  border-spacing: 0;
  border-collapse: collapse; }
.z td {
  padding: 0; }
.bb {
  font-weight: bold; }
.m3 {
  margin-bottom: 3px; }
.m5 {
  margin-bottom: 5px; }
.m10 {
  margin-bottom: 10px; }
.m15 {
  margin-bottom: 15px; }
.m20 {
  margin-bottom: 20px; }
.m25 {
  margin-bottom: 25px; }
.m30 {
  margin-bottom: 30px; }
.m35 {
  margin-bottom: 35px; }
.s10 {
  font-size: 10px;
  line-height: 120%; }
.s11 {
  font-size: 11px;
  line-height: 120%; }
.s12 {
  font-size: 12px;
  line-height: 120%; }
.s13 {
  font-size: 13px;
  line-height: 120%; }
.s14 {
  font-size: 14px;
  line-height: 120%; }
.s15 {
  font-size: 15px;
  line-height: 120%; }
h1 {
  font-size: 24px;
  line-height: 120%;
  color: #434A4D;
  margin: 0 0 3px 0;
  white-space: nowrap; }
h2, h2 a {
  clear: both;
  font-size: 18px;
  line-height: 120%;
  color: #07A2E4;
  margin-top: 10px;
  padding: 2px 0 12px 15px;
  border-bottom: 2px solid #CCCCCC; }
h3 {
  font-size: 15px;
  line-height: 120%;
  color: #000000;
  padding: 0 0 5px 23px;
  margin: 0 5px 20px 0;
  background: url('data:image/gif;base64,R0lGODlhEAAPAMQAAP/abP/QYvTAWsHBweSxTbGxsd2pRaWlpXGu25+fn8+TJpeXl2egxcyRJGCZwV6Ts1mTvbqCHFKPvleNsIODg1CHrEqGtbB0DUmBqEN/sTx3qTt4rTRunGRkZC1nmP///yH5BAUUAB8ALAAAAAAQAA8AAAVw4CcmxUJR4vdMVfodw1J06cq4sEyn0y1yidhMEUlVHJAPx5PQEQiGYgUDQUg0mg+FFgkICBEqwpLZuEQNwDcyPp8VarDbNYWv3atp1S6v9ZBtfEUiPR9VFil2BhciLSISGS4KAQpuHFhnjGdLZnMiIQA7') no-repeat 0 1px;
  border-bottom: 1px solid #CCCCCC; }
#tt h3 {
  color: #2E5B89;
  padding: 0;
  margin: 10px 0;
  background: none;
  border: 0; }
#popup h3 {
  background: url('data:image/gif;base64,R0lGODlhEAAQANX/ACkplDExlDExnDk5nDk5pUJCnEpKnEpKpUpSrUpStVJSpVJSrVJStVpSrVparVpatVpavVpaxmNjzmtrznNztXN7vXt7nISEnISErYSEtYSExoyMrYyMtYyUxpSUrZSUxpycpZyctZyc1qWlvaWl1qWt1q2tzq2t1q2t3rW1zrW11r29zr293sbG58bOxsbOzs7Ozs7O587W59bW1tbW3tbW797e3t7e5+/v7+/v9+/39/f39/f3//f//8DAwP///yH5BAEAAD4ALAAAAAAQABAAQAarQJ8PkZrBjkjYzHQQVhgPDelUOpFIVZFk4askajiabTym4ViRRlcieWAGgxXu1wIEII7uFzfr+2dnaXo1PDmGhzk7aGoVbBAdHxkbIy0oBAQReY0TDxcjMTw9OykAApl6MoWIhjyLgzo3sbI3gYx7f361XQgxOzo7wMGKgo1sxhIREcYTjGwPHAYBIDN0dnhrbRYFFDc8PyoBAtc+DgsHHi4vLy4uIQUFCj5BADs=') no-repeat 0 1px; }
label {
  padding-left: 5px;
  cursor: pointer; }
.left {
  float: left;
  margin: 0 15px 5px 0; }
.right {
  float: right;
  margin: 0 0 5px 15px; }
input, .btn, select, textarea {
  font-size: 11px;
  background: #FFFFFF;
  border: 1px solid #CCCCCC;
  padding: 3px 5px;
  color: #333333; }
#popup textarea {
  width: 670px;
  height: 110px;
  padding: 3px 0;
  background: #F3F3F3;
  border: 0; }
input, img.chk {
  padding: 4px 5px; }
input[type="checkbox"], select {
  padding: 0; }
input[disabled], .grey {
  color: #999999; }
.btn {
  background: url('data:image/gif;base64,R0lGODlhAQAVALMAAP////39/fj4+PPz8+7u7ujp6eTj497f39nZ2dXV1M/PzszMzAAAAAAAAAAAAAAAACH5BAQUAP8ALAAAAAABABUAAAQLEMhJgRikmIOSWhEAOw==') repeat-x 0 100% #F3F3F3;
  padding: 4px 5px 4px 5px;
  cursor: pointer; }
.btn input {
  padding: 0;
  border: 0;
  background: none;
  cursor: pointer; }
a.btn {
  text-decoration: none; }
.chk {
  background: none;
  border: 0; }
.shl {
  color: #436976;
  font-weight: bold;
  font-style: italic; }
ol {
  padding: 0px;
  margin: 10px 0 25px 0; }
ol li {
  margin: 0 0 10px 15px;
  list-style-position: outside;
  list-style-type: decimal; }
.red, .red a {
  color: #8C0100; }
.hr {
  font-size: 1px;
  line-height: 1px;
  height: 1px;
  border-bottom: 1px dotted #CCCCCC; }

#container {
  min-width: 1008px;
  min-height: 100%;
  overflow: hidden; }
#header {
  position: relative;
  min-height: 85px;
  background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAsCAYAAACkJ9JhAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK8AAACvABQqw0mAAAACV0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVggMjAwNId2rM8AAAAtSURBVHicY/j27dt/JgYGBgYI8f//fwYkLjYxNO6/f/+IUozfFJzqiDUei5sBj+4uCG99pbUAAAAASUVORK5CYII=') repeat-x 0 100% #F6F6F6;
  border-bottom: 2px solid #CCCCCC;
  padding: 10px 0 0 15px; }
#body, #popup {
  background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAeCAYAAADtlXTHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK8AAACvABQqw0mAAAACV0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVggMjAwNId2rM8AAAAwSURBVHicY7h69ep/Jn5+fgYmBgYGKMHIyIjMQnCxyTIwMDAwMTExYdeB0yi8hgIAOYUEE8wmb3AAAAAASUVORK5CYII=') repeat-x 0 0 #F3F3F3; }
#first_start {
  padding: 30px 15px; }
#menu {
  float: left;
  width: 315px;
  background: url('data:image/gif;base64,R0lGODlhBQAFAKIAAPz8/Ozs7Onp6efn5+bm5uTk5MzMzAAAACH5BAQUAP8ALAAAAAAFAAUAAAMNaBFgJkA4MIYj2JVtEgA7') repeat-y 100% 0;
  padding: 20px 0 32767px 15px;
  margin-bottom: -32767px; }
#content {
  margin-left: 330px;
  padding: 15px 0 0 30px; }
#popup {
  border: 3px solid #999999;
  position: fixed;
  z-index: 9999;
  width: 680px;
  height: 280px;
  padding: 10px; }

.text {
  float: left;
  width: 450px; }
.console {
  margin-left: 450px;
  padding: 5px 10px 0 0; }
#mmnu {
  position: absolute;
  bottom: 0;
  right: 0; }
#mmnu li {
  background: url('data:image/gif;base64,R0lGODlh9AE2ANUAAPf39/T3+fPz8/Hx8fHy8vDw8PDx8u/w8e/v7+7w8e3w8O3t7ent7unt7+rt7+rq6uTq7Ofn5+Xl5eDn6t3m6eDg4N/f39Lg5d3d3dPg5c7e49ra2tnZ2cra4NfX18na4NXV1cfY38bY3tTU1NPT09LS0sPW3cDV3MHV3L/U273T2s7Ozs3NzczMzLjP2LXO1rTN1rXN1gei5P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEHADMALAAAAAD0ATYAAAb/wJlwBrCAWsikcslsOp/QqHRKrVqv2Kx2y+16v+CweEzejiyAodrC4kQGgrh8Tq/b7/i8fs/v+/+AgYKDhIWGh4iJiouMjYIFER4sFmozICALjpqbnJ2en6ChoqOkpXgLl0MWJAimrq+wsbKztLW2dgUlFUQrmbe/wMHCw8TFmwsrABgbckhxzgLQxtPU1dbX2IkcGCAPzS3P4NHi2eXm5+jptRJHcOrv8PHy840L0vT4+fr78ywsc9Du8RtIsKBBU/cCkjvIsKHDh4MEQpxIsaLFbxczatxIMOFCjiBDijTmcaTJkyhnSUzJsqVLTitfypxJE1DMmjhz6ryps6dP/5Y8fwodujEo0aNIHRpNyrSpvqVOo0pNB3Wq1avUqmLdyvWW1q5gwyL8KLas2Vct1AS4gAKG27dw48qdS7eu3bt48+rdy7ev37+AAwseTLiw4cOIEysOfOJCgEpCLrz4MMHA2cuYFyWYEOLFhUooRDTITLo0IgcmTAy5kEKB6dewAx1QkWFGABcOYuverYeBiwAaOsiRISMOcePFeSsn/UEDCgjDkx8XMH25dbMUUMQgcL27bgcxYngfD/vFiznTq5NfjzU8eunJ2cuf6n6+fbD17+u/mp96/P0AEtWfegEW2FN/Bib4E4IKNogTgw5G+BKEElaIEoUWZhgShhp2mCIRhx6GOBGIIpbIEIkmpjgQiiq2iA+LLsYID4wy1nhODEEAADs=') no-repeat 0 0;
  float: left;
  height: 15px;
  padding: 7px 15px 5px 20px;
  list-style: none;
  cursor: pointer; }
#mmnu li.tab_act {
  background-position: 0 -27px;
  cursor: default; }
#mmnu li * {
  color: #436976;
  text-decoration: none; }
#mmnu li.tab_hover * {
  text-decoration: underline; }
#mmnu li.tab_act * {
  color: #07A2E4; }
.smnu {
  height: 28px;
  border-bottom: 1px solid #CCCCCC;
  margin-bottom: 15px; }
.smnu li {
  float: left;
  background: #FFFFFF;
  height: 9px;
  border: 1px solid #CCCCCC;
  margin: 0 5px 0 0;
  padding: 7px 20px 11px 20px;
  list-style: none;
  cursor: pointer; }
.smnu li.tab_act {
  border: 1px solid #9AA9B6;
  background: #C6D9EC;
  cursor: default; }
.smnu li * {
  font-size: 12px;
  color: #436976;
  text-decoration: none; }
.smnu li.tab_act * {
  font-weight: normal;
  color: #000000; }
.toggler, .open {
  float: right;
  width: 5px;
  height: 9px;
  cursor: pointer;
  background: url('data:image/gif;base64,R0lGODlhCgAJAIAAALS0tP///yH5BAUUAAEALAAAAAAKAAkAAAIRjANwm7nYnIkR0mbpua8+uBQAOw==') no-repeat 0 0; }
.open {
  background-position: -5px 0; }
.inner_els {
  padding-right: 15px; }
.block {
  float: left;
  width: 199px;
  height: 60px;
  white-space: nowrap;
  margin: 0 6px 0 0; }
.instr {
  font-style: italic;
  height: 25px; }
.pages, .print {
  float: left;
  padding-right: 30px; }
.pages * {
  margin-right: 7px; }
.print {
  background: url('data:image/gif;base64,R0lGODlhEAAQANX/ACEYISEhGDExMTk5OUJCQlJSUmNjY2tra3Nzc4SEhIyMjIyMlJSUlJSUnJSt95ycnJyczpyt95yt/6WlpaWlraWlxqWtpaW9/6XWpa2tra2tta3G/7W1tb29vb29xr3Gvb3G573O/8bGxsbO587Ozs7O1s7W3s7e/9bW1tbn/97e3t7n7+fn5+fn7+fn/+/v7+/v9/f398DAwP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADIALAAAAAAQABAAQAaeQJkQQoREIsJk8kEiqUQczKdCmXA8E6UMcgptLhKtbPF4zVqih4KRMAwCAISW670gxcIHivTooP4iGUkMGRMZIigvL08ZDwsMCloPDyUMAwUNiAlzKV1fd3hbnhcOoUIuJyAgIyYkDGJ9GRksMC8rexyvY4ckIiokFh0kgLkyDywsHRMaWAyPDQoHm3kPMTMoDwQAAAIGCZGwSQnfSUEAOw==') no-repeat 0 0;
  font-style: normal;
  padding: 0 0 6px 22px; }
.buttons {
  text-align: right; }
.bord {
  font-size: 12px;
  line-height: 130%;
  border-right: 1px solid #CCCCCC;
  border-bottom: 1px solid #CCCCCC; }
.bord th {
  background: #E9EDEF;
  border-left: 1px solid #CCCCCC;
  border-top: 1px solid #CCCCCC;
  text-align: left;
  padding: 7px; }
.bord th.c {
  text-align: center;
  width: 5%; }
.bord td {
  text-align: center;
  border-left: 1px solid #CCCCCC;
  border-top: 1px solid #CCCCCC;
  padding: 5px 7px 5px 7px; }
.bord td.l {
  text-align: left; }
.bord td.r {
  text-align: right; }
.bord td.nc {
  text-align: left;
  white-space: nowrap; }
td.lch, input#lch_text {
  background: #D5E2F0!important; }
td.le, input#le_text {
  background: #DAE0DC!important; }
td.out, input#out_text {
  background: #D8D8D8!important; }
.hl td {
  background: #ECECEC; }
.nofloat {
  overflow: hidden; }
#popup .btns {
  float: right;
  padding-right: 5px; }
#popup .btns div {
  cursor: pointer;
  width: 10px;
  height: 10px;
  border: 1px solid #999999;
  background: url('data:image/gif;base64,R0lGODlhCAAIAIAAAJmZmf///yH5BAEHAAEALAAAAAAIAAgAAAIOBIJhi7zcYDTpUWiTAgUAOw==') no-repeat 1px 1px; }
</style>
<!--[if lte IE 7]><style type="text/css" media="screen">
h2 {
  margin: 0;
  padding: 12px 0 12px 15px;
  background: #FFFFFF; }
h3 {
  padding-left: 0; }
label {
  cursor: default; }
.btn {
  background: #FFFFFF;
  padding: 4px 0; }
#container {
  min-width: 1004px; }
* html #container {
  width: expression(((document.compatMode && document.compatMode=='CSS1Compat') ? document.documentElement.clientWidth : document.body.clientWidth) < 1010 ? "1004px" : "100%");
  zoom: 1; }
#header {
  background: #F3F3F3; }
* html #header {
  height: 95px;
  he\ight: 85px; }
#popup {
  position: absolute; }
#popup textarea {
  height: 109px; }
#menu {
  border-right: 2px solid #CCCCCC; }
* html #menu {
  border: 0;
  padding-top: 15px; }
* html #all {
  padding: 20px 10px;
  border: 2px solid #CCCCCC; }
* html .smnu li {
  padding: 7px 20px 8px 20px;
  border-bottom: 0; }
* html .smnu li.tab_act {
  border-bottom: 0; }
a.btn {
  padding: 4px 5px 5px 5px; }
* html .block {
  width: 222px; }
.instr {
  margin: -5px 0 5px 0; }
.print {
  padding-left: 0; }
.buttons {
  margin-top: 5px; }
.nofloat {
  zoom: 1; }
* html .ieFix {
  margin-left: -3px; }
</style><![endif]-->
<style type="text/css" media="print">
body {
  font: 12px Arial, Verdana, Helvetica, sans-serif;
  line-height: 130%; }
* {
  padding: 0;
  margin: 0; }
.z {
  border-spacing: 0;
  border-collapse: collapse; }
.z td {
  padding: 0; }
.bb {
  font-weight: bold; }
h2, h2 a {
  clear: both;
  font-size: 18px;
  line-height: 120%;
  margin-top: 10px;
  padding: 2px 0 12px 0;
  border-bottom: 1px solid #CCCCCC; }
#tt h3 {
  font-size: 15px;
  line-height: 120%;
  padding: 0;
  margin: 20px 0 10px 0; }

#container {
  margin: 0 1px;
  width: 99%; }
#tt, #bt {
  margin-top: 1px; }
#header, #menu, .smnu, .print, .buttons {
  display: none; }
#content {
  padding-top: 15px; }
.inner_els {
  page-break-after: always;
  display: block!important; }

.pages {
  text-align: right;
  padding: 5px 4px 0 0; }
.bord {
  font-size: 12px;
  line-height: 130%;
  border-right: 1px solid #CCCCCC;
  border-bottom: 1px solid #CCCCCC; }
.bord th {
  border-left: 1px solid #CCCCCC;
  border-top: 1px solid #CCCCCC;
  text-align: left;
  padding: 7px; }
.bord th.c {
  text-align: center;
  width: 5%; }
.bord td {
  text-align: center;
  border-left: 1px solid #CCCCCC;
  border-top: 1px solid #CCCCCC;
  padding: 5px 7px 5px 7px; }
.bord td.l {
  text-align: left; }
.bord td.r {
  text-align: right; }
.bord td.nc {
  text-align: left;
  white-space: nowrap; }
</style>
<script type="text/javascript">
// Яваскриптовый фреймворк
// Версия: 1.0.28 Final (29.01.2010)
// Авторы: Иван Азарёнок, Григорий Зарубин, Андрей Сидоров (Shogo.Ru)

//<![CDATA[
var suilib = {

  version: 'lite-1.0.28',

  collector: {events:[], elements:[], cache:{}},

  anonymous: function(){},

  client: {
    domSupported:  !!document.getElementById,
    nativeWrapper: !!window.HTMLElement,

    opera:    !!window.opera,
    msie:     !!(document.all && document.all.item && !window.opera && !window.postMessage),
    trident:  !!(document.all && document.all.item && !window.opera),
    safari:   !!(navigator.appVersion && navigator.appVersion.toLowerCase().indexOf('applewebkit') >= 0),
    gecko:    !!(window.Components && window.controllers),
    netscape: !!document.layers
  },

  debug: {
    info: window.console && console.firebug ? window.console.info : this.anonymous,
    error: window.console && console.firebug ? window.console.error : this.anonymous,
    log: window.console && console.firebug ? window.console.log : this.anonymous,
    warn: window.console && console.firebug ? window.console.warn : this.anonymous
  },

  ready: function(method, context, args) {
    if(!this.init.initialize) this.init.initialize = []
    this.init.initialize.push({method:(method || suilib.anonymous), context:(context || window), args:(args || [])})
  },

  init: function() {
    if(suilib.init.done) return null
    suilib.init.done = true
    suilib.body = (!!document.body ? document.body : document.getElementsByTagName('body')[0])
    if(window.addEventListener)
      window.addEventListener('click', suilib.clickCapture, true);
    else
      suilib.clickCapture.$('click', window, document);
    if(arguments.callee.initialize && arguments.callee.initialize.length)
      for(var i=0,l=arguments.callee.initialize.length; i<l; i++)
        arguments.callee.initialize[i].method.
        apply(arguments.callee.initialize[i].context, arguments.callee.initialize[i].args)
  },

  body: {},

  capturedClick: {},

  clickCapture: function(e) {
    suilib.capturedClick = e
  },

  extensions: {
    Array: {
      hasa: function(val) {
        for(var i=0; i<this.length; i++)
          if(this[i]===val) return i
        return false
      },
      walkwith: function(cb) {
        var ret = []
        for(var i=0; i<this.length; i++)
          ret.push(cb(this[i]))
        return ret
      },
      filter: function() {
        var flatten = []
        for(var i=0,l=arguments.length; i<l; i++)
          flatten.push(arguments[i])
        return suilib.domExt.filter.apply(this, flatten)
      },
      hash: function() {
        var result = {}
        for(var i=0,l=this.length; i<l; i++)
          result[i] = this[i]
        return result
      },
      tweener: function(obj, options) {
        return suilib.domExt.tweener.call(this, obj && options ? obj : null, !options ? obj : options)
      }
    },
    String: {
      trim: function(what) {
        var sym = [' ', '\r', '\n'], result = this
        if(what) for(var i=0,l=what.length; i<l; i++) sym.push(what.charAt(i))
        while(sym.hasa(result.charAt(0))!==false) result = result.substr(1)
        while(sym.hasa(result.charAt(result.length-1))!==false) result = result.substr(0, result.length-1)
        return result.toString()
      },
      camelize: function() {
        var parts = this.split('-'), len = parts.length
        if(len == 1) return parts[0];
        var c = this.charAt(0) == '-' ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1) : parts[0]
        for(var i=1; i<len; i++) c += parts[i].charAt(0).toUpperCase() + parts[i].substring(1)
        return c.toString()
      },
      find: function(what) {
        return (this.indexOf(what)>=0 ? true : false)
      }
    },
    Date: {
      isLeapYear: function() {
        var year = this.getFullYear()
        return ((((year%4==0) && (year%100!=0)) || (year%400==0)) ? true : false)
      }
    },
    Function: {
      $: function() {
        var e = arguments[0], g = suilib.client.gecko
        for(var i=1,l=arguments.length; i < l; i++) {
          if(!arguments[i]) continue
          try {
            if(typeof arguments[i]=='object' && 'length' in arguments[i] && 'hasa' in arguments[i]) {
              var clone = []
              arguments[i].walkwith(function(el) { clone.push(el) })
              clone.unshift(e)
              this.$.apply(this, clone)
              continue
            }
            arguments[i] = $(arguments[i]); if(!arguments[i]) continue
            if(arguments[i].attachEvent) arguments[i].attachEvent('on'+e, this)
            else arguments[i].addEventListener(e, this, false)
            if(e!='unload') suilib.collector.events.push([this, e, arguments[i]]);
          } catch(ext) { suilib.debug.error('$\n'+ext) }
        }
        return this
      },
      $$: function() {
        var e = arguments[0], g = suilib.client.gecko
        for(var i=1,l=arguments.length; i < l; i++) {
          if(!arguments[i]) continue
          try {
            if(typeof arguments[i]=='object' && 'length' in arguments[i] && 'hasa' in arguments[i]) {
              var clone = []
              arguments[i].walkwith(function(el) { clone.push(el) })
              clone.unshift(e)
              this.$$.apply(this, clone)
              continue
            }
            arguments[i] = $(arguments[i]); if(!arguments[i]) continue
            if(arguments[i].detachEvent) arguments[i].detachEvent('on'+e, this)
            else arguments[i].removeEventListener(e, this, false)
          } catch(ext) { suilib.debug.error('$$\n'+ext) }
        }
        return this
      }
    }
  },

  domExt: {
    __e__: true,
    $: function() {
      var e = arguments[0]
      for(var i=1,l=arguments.length; i < l; i++)
        if(arguments[i] && arguments[i].$)
          arguments[i].$(e, this)
      return this
    },
    $$: function() {
      var e = arguments[0]
      for(var i=1,l=arguments.length; i < l; i++)
        if(arguments[i] && arguments[i].$$)
          arguments[i].$$(e, this)
      return this
    },
    filter: function(tag, cls, attr, deep) {
      var result = []; result.filter = suilib.extensions.Array.filter
      if(this instanceof Array) {
        for(var i=0,l=this.length; i<l; i++)
          if(this[i] && this[i].filter)
            result = result.concat(this[i].filter(tag, cls, attr, deep))
        return result
      }
      var list = (deep ? this.getElementsByTagName(tag || '*') : this.childNodes)
      outerLoop:
      for(var i=0,l=list.length; i<l; i++) {
        if(!list[i] || list[i].nodeType!=1) continue
        if(!deep && tag && tag!='*' && list[i].tagName.toLowerCase()!=tag.toLowerCase()) continue
        if(cls && list[i].className.split(' ').hasa(cls)===false) continue
        if(attr) for(var j in attr) try {
          if(list[i].getAttribute(j).toLowerCase()!==attr[j].toLowerCase()) continue outerLoop
        } catch(e) { continue outerLoop }
        result.push($(list[i]))
      }
      return result
    },
    unset: function(rmid) {
      if(rmid && this.removeAttribute) {
        var oid = this.getAttribute('id')
        if(suilib.collector.cache[oid]) delete(suilib.collector.cache[oid])
        this.removeAttribute('id')
      }
      this.parentNode.removeChild(this)
      return this
    },
    empty: function(deep, rmid) {
      while(this.firstChild) {
        if(deep && this.firstChild.nodeType==1) $(this.firstChild).empty(deep, rmid)
        if(rmid && this.firstChild.removeAttribute) {
          var oid = this.firstChild.getAttribute('id')
          if(suilib.collector.cache[oid]) delete(suilib.collector.cache[oid])
          this.firstChild.removeAttribute('id')
        }
        this.removeChild(this.firstChild)
      }
      return this
    },
    show: function(interval, args) {
      if(interval) {
        args = args.split(','); var params = {}
        for(var i=0,l=args.length; i<l; i++) switch(args[i].trim()) {
          case 'fade':
            params.opacity = [0, 100]
            this.setstyle('opacity:0')
          break
        }
        this.style.display = ''
        this.animate(interval, params)
      } else this.style.display = ''
      return this
    },
    hide: function(interval, args) {
      if(interval) {
        args = args.split(','); var params = {}, self = this
        for(var i=0,l=args.length; i<l; i++) switch(args[i].trim()) {
          case 'fade':
            params.opacity = [100, 0]
            this.setstyle('opacity:100')
          break
        }
        this.animate(interval, params, function() {
          self.hide(); self.setstyle('opacity:100') })
      } else this.style.display = 'none'
      return this
    },
    toggle: function(node, interval, args) {
      if(!node) return false
      if(interval) {
        args = args.split(','); var params = {}, effect, self = this
        for(var i=0,l=args.length; i<l; i++) switch(args[i].trim()) {
          case 'fade':
            params.opacity = [100, 0]
            this.setstyle('opacity:100')
            effect = args[i].trim()
          break
        }
        this.animate(interval, params, function() {
          self.hide(); self.setstyle('opacity:100'); $(node).show(interval, effect) })
      } else {
        this.style.display = 'none'
        $(node).style.display = ''
      }
      return this
    },
    animate: function(interval, args, complete, aic) {
      var timer = 0, step = 0, self = this, icall = (aic || 100)
      var stepdelta = interval * 1000 / icall

      var convert = function(prop, val) {
        var result
        switch(prop.camelize().trim()) {
          case 'width': case 'height': case 'left': case 'top': case 'fontSize':
            result = val + 'px'
          break
          case 'color': case 'backgroundColor':
            result = '#'+suilib.Color.hsl2hex(val, 100, 100)
          break
          default:
            result = val
        }
        return result
      }
      var callback = function(args, step) {
        var fn = arguments.callee
        if(!fn.$queue)  fn.$queue  = {}
        if(!fn.$ignore) fn.$ignore = {}

        for(var a in args) if(!fn.$queue[a]) {
          fn.$queue[a] = false
          if(typeof args[a]=='function' && args[a].call) {
            this.setstyle(a+':'+args[a].call(fn, step, a))
            continue
          }
          if(!('$'+a in fn)) fn['$'+a] = args[a][0]
          var delta = (Math.max(args[a][0], args[a][1]) - Math.min(args[a][0], args[a][1])) / stepdelta
          if(!delta) delta = 1
          this.setstyle(a+':'+convert(a, fn['$'+a]))
          if(args[a][1] > args[a][0]) {
            fn['$'+a] += delta
            if(fn['$'+a] >= args[a][1]) {
              fn.$queue[a] = true
              this.setstyle(a+':'+convert(a, args[a][1]))
            }
          } else if(args[a][1] < args[a][0]) {
            fn['$'+a] -= delta
            if(fn['$'+a] <= args[a][1]) {
              fn.$queue[a] = true
              this.setstyle(a+':'+convert(a, args[a][1]))
            }
          } else {
            this.setstyle(a+':'+convert(a, args[a][0]))
            fn.$queue[a] = true
          }
        }

        var done = true; for(var i in fn.$queue) if(!fn.$ignore[i] && fn.$queue[i]!==true) done = false
        if(done) fn.stop()
      }
      callback.loop = function(mode, prop) {
         this.$ignore[prop] = !!mode
      }
      callback.stop = function() {
        clearInterval(timer); if(complete) complete()
      }
      if(this.$intervalid) clearInterval(this.$intervalid)
      this.$intervalid = timer = setInterval(function(){step++; callback.apply(self, [args, step])}, icall)
    },
    tweener: function(obj, options) {
      if('jTweener' in window) return $t(obj && typeof(obj)=='object' && options ? obj : this, !options ? obj : options); else {
        suilib.debug.warn('jTweener not included!');
        return {
          'tween'         : suilib.anonymous,
          'percent'       : suilib.anonymous,
          'stop'          : suilib.anonymous,
          'addOptions'    : suilib.anonymous,
          'clearOptions'  : suilib.anonymous,
          'removeOptions' : suilib.anonymous
        }
      }
    },
    setstyle: function(style) {
      var rules = style.split(';')
      for(var i=0,l=rules.length; i<l; i++) {
        var hash = rules[i].split(':')
        var prop = hash[0].camelize().trim()
        try { switch(prop) {
          case 'float':
            this.style['styleFloat'] = hash[1].trim()
            this.style['cssFloat']   = hash[1].trim()
          break
          case 'opacity':
            var op = parseInt(hash[1], 10)
            if(document.body.filters) {
              var alph = (this.filters['DXImageTransform.Microsoft.alpha'] || this.filters.alpha)
              if(alph) alph.opacity = op
              else this.style.filter += "progid:DXImageTransform.Microsoft.Alpha(opacity="+op+")"
            } else {
              var aop = op / 100
              this.style.opacity = aop;
              this.style.MozOpacity = aop;
              this.style.KhtmlOpacity = aop;
            }
          break
          default:
            this.style[prop] = hash[1].trim()
        } } catch(exc) {  }
      }
      return this
    },
    classAdd: function(cls) {
      if(cls && typeof cls==="string") {
        var classNames = (cls || "").split(/\s+/);
        if(!this.className) {
          this.className = cls;
        } else {
          var className = " " + this.className + " ";
          for(var c=0,cl=classNames.length; c<cl; c++)
            if(className.indexOf(" " + classNames[c] + " ") < 0) this.className += " " + classNames[c];
        }
      }
      return this
    },
    classReplace: function(clsNew, clsOld) {
      if(typeof clsOld=='object' && clsOld.length)
        for(var i=0,l=clsOld.length; i<l; i++) this.classRemove(clsOld[i])
      else this.classRemove(clsOld)
      this.classAdd(clsNew)
      return this
    },
    classRemove: function(cls) {
      if((cls && typeof cls==="string") || cls===undefined ) {
        var classNames = (cls || "").split(/\s+/);
        if(this.className) {
          if(cls) {
            var className = (" " + this.className + " ").replace(/[\n\t]/g, " ");
            for(var c=0,cl=classNames.length; c<cl; c++) {
              className = className.replace(" " + classNames[c] + " ", " ");
            }
            this.className = className.substring(1, className.length - 1);
          } else this.className = "";
        }
      }
      return this
    },
    offset: function(d) {
      var x = this.offsetLeft,y = this.offsetTop
      if(this.offsetParent && d) {
        var pos = $(this.offsetParent).offset(d)
        x += pos[0]; y += pos[1]
      }
      return [x,y]
    },
    html: function(html) {
      if(html && html.length && html.length===parseInt(html.length, 10))
        this.innerHTML = html
      return this.innerHTML
    },
    add: function(e, a, c) {
      var child = $(document.createElement(e))
      if(a) for(var p in a) {
        switch(p) {
          case 'class': child.classAdd(a[p]); break
          case 'style': child.setstyle(a[p]); break
          case 'innerHTML': child.html(a[p]); break
          default: child.setAttribute(p, a[p])
        }
      }
      if(c) for(var i=0,l=c.length; i<l; i++) if(c[i]) child.appendChild(c[i])
      if(this && this!=window && this!=document && this.appendChild) this.appendChild(child)
      return child
    },
    addtext: function(t) {
      var child = document.createTextNode(t)
      if(this && this!=window && this!=document && this.appendChild) this.appendChild(child)
      return child
    }
  },

  addProps: function(d, s, p) {
    for(var p in s)
      if(d[p] && p) continue
      else d[p] = s[p]
    return d
  },

  ajax: function(url, params, method, handler) {
    if(!url) url = document.location.protocol + '//' + document.location.hostname +
                   document.location.pathname + document.location.search
    handler  = (handler || suilib.anonymous)
    var pick = function() {
      var v  = [
        function(){return new XMLHttpRequest()},
        function(){return new ActiveXObject("Msxml2.XMLHTTP")},
        function(){return new ActiveXObject("Msxml3.XMLHTTP")},
        function(){return new ActiveXObject("Microsoft.XMLHTTP")}
      ], result
      for(var i=0,l=v.length; i<l; i++) {
        try { result = v[i]()
        } catch(exc) { continue }
        break
      }
      return result
    }
    var provider = pick()
    var xmlhttp  = provider
    var closure  = function() {
      handler({readyState: xmlhttp.readyState,
               statusCode:(xmlhttp.readyState==4) ? xmlhttp.status : null,
               responseJS:(xmlhttp.readyState==4 && xmlhttp.status==200) ?
                          (function(x){try{eval('try{var r='+(x.responseText || 'null')+'}catch(e){};')}catch(e){ suilib.debug.error(e+'\n\n'+x.responseText) };return r})(xmlhttp) : null
               })
      if(xmlhttp.readyState==4) xmlhttp = null
    }
    if(!!params.hasa) params = params.join('&')
    if(method=='get') url += (url.match(/\?/) ? '&' : '?') + params
    url += (url.match(/\?/) ? '&' : '?') + '$js=' + ((new Date()).getTime())
    try {
      provider.open(method, url.toLowerCase(), true)
      provider.onreadystatechange = closure
      provider.setRequestHeader('X-Requested-With', 'Shogo UI/'+suilib.version)
      if(method=='post') provider.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')
      provider.setRequestHeader('Accept', 'text/javascript, text/html, application/xml, text/xml, */*')
      provider.setRequestHeader('Connection', 'close')
      provider.send(method=='post'?params:null)
    } catch(exc) {suilib.debug.error(exc+' '+params)}
    return provider
  },

  get: function(params, handler) {
    return this.ajax(null, params, 'get', handler)
  },

  post: function(params, handler) {
    return this.ajax(null, params, 'post', handler)
  },

  switchWait: function(mode, loader) {
    try { // это для ебучего ie6
      var ie = suilib.client.trident, szs = ie ? suilib.screensizes() : [];
      if(!arguments.callee.floatMover) arguments.callee.floatMover = function(e) {
        var scrlX  = document.documentElement.scrollLeft + document.body.scrollLeft;
        var scrlY  = document.documentElement.scrollTop  + document.body.scrollTop;
        floatloader.style.left = parseInt(e.pageX ? e.pageX : e.x+scrlX, 10) - 16 + 'px';
        floatloader.style.top  = parseInt(e.pageY ? e.pageY : e.y+scrlY, 10) - 15 + 'px';
      }

      var ipath   = 'i/ajax/',
          loaders = [ ipath + 'loader.gif', ipath + 'ajax.' + (ie ? 'gif' : 'png')];
      if(mode) {
        if(loader && loaders[loader]) {
          var floatloader = new Image();
          floatloader.src = loaders[loader];
          suilib.body.appendChild(floatloader);
          $(floatloader).setstyle('position:absolute; z-index:200');
          var evt = (window.event || suilib.capturedClick);
          try { if(evt.type!='click') evt = (ie ? window.event : suilib.capturedClick) } catch(e) {}
          var scrlX  = document.documentElement.scrollLeft + document.body.scrollLeft;
          var scrlY  = document.documentElement.scrollTop  + document.body.scrollTop;
          if(evt) {
            var sl = parseInt(evt.pageX ? evt.pageX : evt.x+scrlX, 10) - 16;
            var st = parseInt(evt.pageY ? evt.pageY : evt.y+scrlY, 10) - 15;
            szs[2] = ie ? szs[2] : Math.max(document.body.scrollWidth, window.innerWidth);
            szs[3] = ie ? szs[3] : Math.max(document.body.scrollHeight, window.innerHeight);
            if(isNaN(sl)) sl = Math.ceil(szs[2]/2) - 16;
            if(isNaN(st)) st = Math.ceil(szs[3]/2) - 16;
            $(floatloader).setstyle('top:' + st + 'px; left:' + sl + 'px');
          }
          if(!arguments.callee.floatloader) arguments.callee.floatloader = floatloader;
          arguments.callee.floatMover.$('mousemove', window, document);
        } else if(loader) { // невидимый запрос
        } else { // дефолтный статусбар
          if(!arguments.callee.wdiv)
            arguments.callee.wdiv = $(suilib.body).add('div', {'style' : 'position:' + (ie ? 'absolute' : 'fixed') + '; left:0; top:0; z-index:9998; margin:0; background:#000000; width:' + (ie ? szs[0]+'px' : '100%') + '; height:' + (ie ? szs[3]+'px' : '100%')});
            arguments.callee.wdiv.setstyle('opacity:30');
          if(!arguments.callee.idiv)
            arguments.callee.idiv = $(suilib.body).add('div', {'style' : 'position:' + (ie ? 'absolute' : 'fixed') + '; z-index:9999; text-align:center; padding-top:20%; color:#EBEBEB; width:100%; left:0; top:' + (ie ? (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop)+'px' : '0')}, [
              addtext('Пожалуйста, подождите...'),
              add('br'),
              add('img', {'src' : loaders[0]})
            ]);
        }
      } else {
        if(loader && loaders[loader]) {
          arguments.callee.floatMover.$$('mousemove', window, document);
          try { suilib.body.removeChild(arguments.callee.floatloader) } catch(e) {}
          arguments.callee.floatMover = null; arguments.callee.floatloader = null;
        } else if(loader) { // невидимый запрос
        } else { // дефолтный статусбар
          $(arguments.callee.wdiv).unset(true);
          $(arguments.callee.idiv).unset(true);
          arguments.callee.wdiv = null; arguments.callee.idiv = null;
          window.scrollBy(1,1);
          window.scrollBy(-1,-1);
        }
      }
    } catch(err) {}
  },

  screensizes: function() {
    var wW = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0;
    var wH = window.innerHeight ||  document.documentElement.clientHeight || document.body.clientHeight || 0;

    return [wW, wH, Math.min(document.body.scrollWidth, wW), Math.max(document.body.scrollHeight, wH)];
  },

  free: function() {
    for(var i=0; i<this.length; i++) {
      if(!this[i][0] || !this[i][0].$$ || !this[i][1] || !this[i][2]) continue
      this[i][0].$$(this[i][1], this[i][2]); this[i][0] = this[i][2] = this[i] = null
    }
  }
}

;(function(h){for(var n in h)   suilib.addProps(window[n].prototype, h[n])})(suilib.extensions)
if(suilib.client.nativeWrapper) suilib.addProps(window.HTMLElement.prototype, suilib.domExt)
var add = suilib.domExt.add, addtext = suilib.domExt.addtext, __e__ = true

function $() {
  if(!arguments[0]) return null
  var r = []
  if(arguments.length > 1)
    for(var i=0,l=arguments.length; i < l; i++)
      r.push($(arguments[i]))
  else switch(typeof arguments[0]) {
    case 'string': try {
      r = suilib.collector.cache[arguments[0]] ? suilib.collector.cache[arguments[0]] : document.getElementById(arguments[0])
      suilib.collector.cache[arguments[0]] = r } catch (e) { suilib.debug.error('[wrong node]:\n'+e) }
    break
    default:
      r = arguments[0]
  } try {
  if(arguments.length==1 && !r.__e__) r = suilib.addProps(r, suilib.domExt, true)
  } catch(e) { suilib.debug.error('[extend error]: '+arguments[0]+'\n'+e) } return r
}

;(function() {
  if(document.addEventListener) document.addEventListener("DOMContentLoaded", function(){
    document.removeEventListener("DOMContentLoaded", arguments.callee, false);
    suilib.init();
  }, false)
  if(document.attachEvent) {
    document.attachEvent("onreadystatechange", function(){
      if(document.readyState==="complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        suilib.init();
      }
    });
    if(document.documentElement.doScroll && window==window.top) (function(){
      if(suilib.init.done) return;
      try {
        document.documentElement.doScroll("left");
      } catch(e) {
        setTimeout(arguments.callee, 0);
        return;
      }
      suilib.init();
    })();
  }
  window.onload = suilib.init;
  (function() {
    suilib.free.call(suilib.collector.events)
    with(suilib.collector)
      for(var i=0; i<cache.length; i++)
        cache[i] = null
  }).$('unload', window)
})();

suilib.Color = {
  rgb2hex: function(rgb) {
    var x = '0123456789ABCDEF', s = rgb.split(','), hex = ''
    for(var i=0; i<3; i++) {
      var n  = parseInt(s[i], 10)
      hex += x.charAt(n >> 4) + x.charAt(n & 15)
    }
    return hex
  },

  hex2rgb: function(hex) {
    var x = '0123456789ABCDEF', c = []
    hex = hex.toUpperCase()
    for(var i=0; i<6; i+=2) c.push(16 * x.indexOf(hex.charAt(i)) + x.indexOf(hex.charAt(i+1)))
    c = c.join(', '); return c
  },

  hsl2rgb: function(hue, sat, lum) {
    var R, G, B, nH, nS, nL, nF, nP, nQ, nT, lH
    var lim = function(val, l, h) {
      if(val < l) val = l; if(val > h) val = h
      return val
    }
    if(sat > 0) {
      nH = hue / 60; nL = lum / 100; nS = sat / 100;
      lH = parseInt(nH, 10); nF = nH - lH
      nP = nL * (1 - nS); nQ = nL * (1 - nS * nF); nT = nL * (1 - nS * (1 - nF))
      switch (lH) {
        case 0:
          R = nL * 255; G = nT * 255; B = nP * 255
        break
        case 1:
          R = nQ * 255; G = nL * 255; B = nP * 255
        break
        case 2:
          R = nP * 255; G = nL * 255; B = nT * 255
        break
        case 3:
          R = nP * 255; G = nQ * 255; B = nL * 255
        break
        case 4:
          R = nT * 255; G = nP * 255; B = nL * 255
        break
        case 5:
          R = nL * 255; G = nP * 255; B = nQ * 255
        break
      }
    } else {
      R = (lum * 255) / 100; G = R; B = R
    }
    return parseInt(lim(R, 0, 255), 10)+', '+parseInt(lim(G, 0, 255), 10)+', '+parseInt(lim(B, 0, 255), 10)
  },

  hsl2hex: function(hue, sat, lum) {
    return this.rgb2hex(this.hsl2rgb(hue, sat, lum))
  }
};
//]]>
</script>
</head>

<body>

<div id="container">
  <div id="header">
    <div class="text">
      <h1>Система футбольной статистики</h1>
      <div class="desc">Football Statistics System (v3.0)</div>
    </div>

    <div class="console"><span class="red">Полностью обособленная динамическая система сбора футбольной статистики в одном файле.</span> Не требует никакого дополнительного софта, кроме браузера (с включенным javascript). Все данные в определенном виде необходимо сохранять самостоятельно простым копи-пастом ;-)</div>

    <ul id="mmnu"><li></li></ul>
  </div>

  <h2 id="hdr">Панель статистики</h2>

  <div id="body">

    <div id="first_start" style="display:none;">
      <p class="m20">Это первый запуск приложения. Для начала работы Вам необходимо создать хотя бы один турнир и заполнить его командами. Вы можете создать несколько различных турниров с любым количеством групп и команд в каждом.<br />Для каждой команды можно указать один или несколько статусов, показывающих её заслуги по итогам прошлого сезона, а также назвать и выделить цветом три зоны в турнирной таблице.</p>

      <form id="trn" action="">
        <div class="m15"><b>Название турнира:</b>&nbsp;&nbsp;<input type="text" size="100" id="trn_name" />&nbsp;&nbsp;<span class="btn"><input type="button" value="Сохранить турнир" id="trn_save" /></span> <span class="btn"><input type="button" value="Очистить поля" id="trn_reset" /></span></div>
        <div class="m35"><b>Число групп:</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type="text" size="2" id="groups_num" value="1" />&nbsp;&nbsp;<b>по</b>&nbsp;&nbsp;<input type="text" size="2" id="commands_num_0" />&nbsp;&nbsp;<b>команд</b>&nbsp;&nbsp;&nbsp;&nbsp;<span class="btn"><input type="button" value="Добавить" id="groups_add" /></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" class="chk" id="trn_results" /><label for="trn_results">сохранять результаты</label></div>

        <div id="groups"></div>

        <div class="hr m20" style="clear:both;">&nbsp;</div>
        <div align="center"><span class="btn"><input type="button" value="Запустить систему" id="sys_load" /></span>&nbsp;&nbsp;<span class="btn"><input type="button" value="Сбросить все данные" id="data_reset" /></span></div>
      </form>
    </div>

    <div id="main" style="display:none;">
      <div id="menu">
        <div class="toggler" id="toggler" title="Скрыть/раскрыть левый блок"></div>

        <div id="all">
          <h3>Ввод данных</h3>

          <div id="group_div"></div>

          <div id="input_tour_div"></div>

          <div class="m5"><span id="com_home_span"></span><input type="text" size="30" value="" id="com_home_inp" style="display:none;" /></div>
          <div class="m5"><input type="text" size="2" maxlength="2" value="0" id="count_home" />&nbsp;<b>:</b>&nbsp;<input type="text" size="2" maxlength="2" value="0" id="count_guest" />&nbsp;&nbsp;&nbsp;&nbsp;<span id="extra_ps_span" style="display:none;"><input type="checkbox" class="chk" id="extra_ps" /><label for="extra_ps">серия пенальти</label></span></div>
          <div class="m5" id="extra_ps_div" style="display:none;"><input type="text" size="2" maxlength="2" value="0" id="count_home_ps" />&nbsp;<b>:</b>&nbsp;<input type="text" size="2" maxlength="2" value="0" id="count_guest_ps" /></div>
          <div class="m15"><span id="com_guest_span"></span><input type="text" size="30" value="" id="com_guest_inp" style="display:none;" /></div>

          <div id="extra_block">
            <div class="m20"><input type="checkbox" class="chk" id="extra" /><label for="extra">дополнительный</label>&nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" class="chk" checked="checked" id="extra_save" /><label for="extra_save">сохранять бомбардиров</label></div>
            <div class="m10" id="extra_group_div" style="margin-top:-10px;overflow:hidden;height:0;">Cтадия:&nbsp;&nbsp;<span id="extra_group_span"></span><input type="text" size="30" value="" id="extra_group_inp" style="display:none;" /></div>
          </div>

          <div id="bombs_input"></div>

          <div class="m20"><span class="btn"><input type="button" value="Добавить матч" id="match_add" /></span> <span class="btn"><input type="button" value="Сохранить данные" id="data_save" /></span></div>

          <div class="hr m10">&nbsp;</div>

          <p style="padding-right:40px;">Выберите принимающую и гостевую команды и введите счет матча. В появившемся блоке появится возможность заполнить бомбардиров матча.<br /><span class="red">Учтите, что при каждой смене команды или счета блок ввода бомбардиров будет перестраиваться заново!</span></p>
        </div>
      </div>

      <div id="content">
        <ul class="smnu">
        <li class="inner_hds"><b>Результаты</b></li>
        <li class="inner_hds"><b>Турнирная таблица</b></li>
        <li class="inner_hds"><b>Бомбардиры</b></li>
        </ul>

        <div class="inner_els">
          <div class="buttons m10"><b>Показать:</b> <span id="r_tours_span"></span></div>
          <div id="rt"></div>
          <div class="instr">
            <div class="print"><a href="#" id="r_print">Распечатать статистику</a></div>
            <div class="buttons">Последняя редакция: <b></b></div>
          </div>
        </div>

        <div class="inner_els">
          <div id="tt"></div>
          <div class="instr">
            <div class="print"><a href="#" id="t_print">Распечатать статистику</a></div>
            <div class="buttons">Последняя редакция: <b></b></div>
          </div>
        </div>

        <div class="inner_els">
          <div class="buttons m10"><b>Выводить по:</b> <select id="b_types"><option value="0">голам</option><option value="1">командам</option></select>&nbsp;&nbsp;&nbsp;&nbsp;<b>Сортировать игроков по:</b> <select id="b_sorts"><option value="0">фамилии</option><option value="1">командам</option><option value="2">голам</option></select></div>
          <div id="bt"></div>
          <div class="instr">
            <div class="pages"></div>
            <div class="buttons">Последняя редакция: <b></b></div>
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<div id="popup" style="display:none;">
  <div class="btns"><div id="data_close"></div></div>
  <h3>Сохранение данных</h3>
  <div class="m10">Вставьте выделенную ниже строчку в самый низ исходного кода этой страницы между указанными комментариями, заменив ей уже существующую. Затем сохраните страницу и нажмите кнопку <b>"Обновить систему"</b>.</div>
  <p class="red">/* Все данные (начало вставки) */</p>
  <textarea id="data" cols="60" rows="6" readonly="readonly"></textarea>
  <p class="red m20">/* Все данные (конец вставки) */</p>
  <div align="center"><span class="btn"><input type="button" value="Обновить систему" id="data_refresh" /></span></div>
</div>

<script type="text/javascript">
//<![CDATA[
/*** Известные проблемы
  - картинки не отображаются в браузерах IE v6-7;
  - в Safari v4.0 некорретно работает показ результатов при выборе тура или стадии через селектор;
  - из-за багов Google Chrome v3-4 и Opera v9.22, вывод отсортированных данных в этих браузерах (например, в таблицах бомбардиров или селекторе выбора туров) работает неправильно;
  - в любых Safari и Chrome окно "Сохранение данных" не закрывается при нажатии на ESC.
***/


/*** История версий
v3.0 (16.02.10):
  Реализована возможность добавления дополнительных матчей (доступна только при включённом сохранении результатов):
    - такие матчи не входят в групповую турнирную сетку, их результаты доступны при просмотре отдельно, а авторы голов
      при необходимости могут быть сохранены в общую таблицу (но только для команд, которые там уже есть);
    - возможно добавление квалификационных матчей перед групповым этапом, стыковых, дополнительных или плейофф-матчей
      после него, а также переигровки матча любого тура (в этом случае вся общая статистика будет корректироваться "на лету");
    - добавлена возможность выбора уже сохранённой стадии (для объединения нескольких дополнительных матчей в одну логическую группу).
  Теперь система поддерживает создание турниров с несколькими группами (таких, как Лига чемпионов УЕФА):
    - при этом статистика результатов матчей, бомбардиров, а также дополнительных матчей остаётся общей;
    - количество команд в разных группах можно варьировать.
  Первый запуск:
    - добавлена поддержка создания турниров с несколькими группами;
    - переделан выбор подсветки мест в турнирной таблице (также добавлена возможность изменения названий зон подсветки);
    - улучшена система защиты от возможных ошибок.
  В сортировке команд теперь учитывается дополнительный матч между командами при абсолютном равенстве всех показателей.
  Модернизирована "защита от дурака", не дающая вводить неверные значения или выбирать неверные комбинации в блоке "Ввод данных".
  Псевдонавигация поддерживает сохранение группы в блоке "Ввод данных".
  Для неактивных чекбоксов теперь красиво затеняется их подпись.
  Suilib обновлена до финального релиза. Дополнен парсер объектов.
  Пофиксены баги:
    - сохраняемые данные портились, если при создании турнира появлялась одна из ошибок ввода данных;
    - сортировка по голам, забитым на чужом поле во всех матчах, работала неверно (пункт 6);
    - система падала после добавления матча, если в нём были забиты мячи и не было ни одного автогола.

v2.0 (15.01.10):
  Реализованы сохранение и вывод результатов матчей в турах (включается опционально при создании турнира):
    - при вводе матча теперь необходимо выбирать тур (для удобства сделан автовыбор);
    - добавлены поля для ввода минут матча, когда были забиты голы;
    - просмотр результатов возможен как для одного тура, так и для всех;
    - сделано автоопределение первого показываемого тура, если он не был задан при открытии в урле.
  Реализована полная сортировка по правилам распределения команд в турнирной таблице (с учётом всех пунктов регламента ЧР).
  Умный вывод ссылки для печати статистики и первоначальное автооткрытие рабочей вкладки.
  Багфиксы вёрстки, модернизирована и отлажена псевдонавигация.
  Окошко "Сохранение данных" теперь можно также закрывать нажатием клавишы ESC и кликом в пустое место экрана.
  Обновлена suilib. Фиксы функции заполнения селекторов и объекта "Динамические вкладки".

v1.9 (10.11.09):
  Реализована псевдонавигация, теперь можно обмениваться ссылками на нужную страничку в системе.
  Обновлена suilib, размеры экрана теперь возвращает её встроенный метод.
  Багфикс и дополнения парсера объектов, фиксы обработки смены сортировки бомбардиров и объекта "Динамические вкладки".

v1.8 (06.08.09):
  Доработка вывода тура, обновлена suilib.

v1.7 (20.07.09):
  Багфиксы вывода тура и парсера объектов.

v1.6 (15.07.09):
  Обновлена suilib.

v1.5 (13.07.09):
  Теперь в заголовке выводится прошедший/текущий тур. Обновлена suilib.

v1.4 (05.06.09):
  Добавлена возможность печати статистики, suilib обновлена до стабильного релиза.

v1.3 (27.03.09):
  Обновлена suilib.

v1.2 (25.03.09):
  Полная поддержка IE8.

v1.1 (18.03.09):
  Теперь авторы автоголов доступны в селекторе выбора бомбардиров.
  Переработан механизм удаления/объединения дубликатов (старый оказался глючным).

v1.0 (16.03.09):
  Первый стабильный релиз.
***/


/*** Cистема футбольной статистики ***/
var $key, $total = [0, true, false], $autogoals = [], $results = {}, $isResults = false, $extra_names = {}, $empty = true;
var $url = {
  'champ' : 1,
  'group' : 1,
  'tab'   : false,
  'tour'  : false,
  'bombs' : [0, 0]
};
var $alias = {
  'lch'   : 'Зона Лиги чемпионов УЕФА',
  'le'    : 'Зона Лиги Европы УЕФА',
  'out'   : 'Зона вылета',
  'champ' : [
            'Действующий чемпион',
            'data:image/gif;base64,R0lGODlhDgANANUAAPnu0ffuzPjsyPXpuPPov/jos/PnvfPnt/flrPbipPDjqvDiqe7bnPLciPTac/bVdvPVYOjUf/HNaPLLM//LAPPHOP/KAP/JAP3HA/bHFPTIG//HAP/GAP/FAP/EAPTEHvLFEv/BAP3CAP3AAPvBAP3BAPK+EPO9B/K7APS6APe5APC4AP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEHACwALAAAAAAOAA0AAAZSQJZwOAgMj0iTBMlkjVTN46HTYR4Aw4nF0hgKDAqUZ+y5mM8rghAiOp9JCWZmQ99ooiC3o3kIUSgYFCUHTBUcH0InHAVMKQhHDytIDAtMEYQsQQA7'
            ],
  'cup'   : [
            'Действующий обладатель Кубка',
            'data:image/gif;base64,R0lGODlhEAAMANUAAP3vqv/ts//krv/boP/Zkf/gAP3WZP/XUv/ZJv/QhuvVgOnTfv/YAP/WEf3TOOrRcf/RI//UAOnPcefOcv/OFufNZufMav/OCebLWufKYubJXv/JAPXLBuTGVeTGTu/FJP/AK//BEebDRebBQv+8HeO/Rt++Q+2/Bf26AOC6LeS5Jv2yAPe1AN62JuO4CumyIeWxHu+uBOCtJeOqB/6cAP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEHADUALAAAAAAQAAwAAAZrwJpQaNGURpjKUNgRqgChjTQSQcGEnlHJkgpQKAlCo7B5WUajhaSmMIBIAwFkQ3vUHvaW8HOIQBBkMUJ6QiV3DhdUESsYNSZLNSUZHhwMDCyShpBLJ4Kbnxgjn58PGaObeKdDEykuMzITkEEAOw=='
            ],
  'new'   : [
            'Новичок лиги',
            'data:image/gif;base64,R0lGODlhDQAMAIAAAIwBAP///yH5BAEHAAEALAAAAAANAAwAAAIXjA+nCr3c3It00ftCzEjyzWleBn7jdBYAOw=='
            ]
};

/* Смена заголовка */
function makeHeader(text) {
    $('hdr').html('Панель статистики :: ' + text);
}

/* Возвращает минимальное число в массиве */
function getMin(arr) {
  return Math.min.apply(Math, arr);
}

/* Возвращает максимальное число в массиве */
function getMax(arr) {
  return Math.max.apply(Math, arr);
}

/* Текущее время в нужном формате */
function currentTime() {
  var all = new Date();
  return ((all.getDate() < 10) ? '0' : '') + all.getDate() + '.' + ((all.getMonth() < 9) ? '0' : '') + (parseInt(all.getMonth(), 10) + 1) + '.' + all.getFullYear().toString().substr(2) + ' ' + all.getHours() + ((all.getMinutes() < 10) ? ':0' : ':') + all.getMinutes();
}

/* Добавляет в урл параметры для псевдонавигации по системе или считывает их текущее значение

  champ  - глобальное переключение между турнирами (верхнее меню), по умолчанию - 1
  tab(1) - опционально, по умолчанию открывается Результаты (комбинации tour - от 1 до последнего тура, -100 для всех туров и (<-1 || >последний тур) для дополнительных матчей, по умолчанию - максимальный тур или стадия, содержащие хотя бы один матч), если они были включены
      2  - Турнирная таблица
      3  - Бомбардиры (комбинации bombs - [0,1], [1,1], [1,2], [0,0] по умолчанию)
*/
function navi(mode) {
  // Парсим урл и заполняем глобальный хэш $url
  if(!mode) {
    var pars = document.location.hash.split(/\&/);
    pars.walkwith(function(el) {
      if(el) {
        var ta = el.split(/\=/);
        switch(ta[0]) {
          case 'group':
            $url.group = parseInt(ta[1], 10); break;
          case 'tab':
            $url.tab = parseInt(ta[1], 10); break;
          case 'tour':
            $url.tour = parseInt(ta[1], 10); break;
          case 'bombs':
            $url.bombs = eval(ta[1]); break;
          default:
            $url.champ = parseInt(ta[1], 10);
        }
      }
    });
  }

  // Меняем урл на основе глобального хэша
  else
    document.location.hash = '#champ=' + $url.champ + '&group=' + $url.group + '&tab=' + $url.tab + '&tour=' + $url.tour + '&bombs=' + objTools.parse($url.bombs);
}

/* Добавляет массив опций в селектор */
function addOption(sid, attr) {
  if(attr && attr.length)
  for(var i=0,l=attr.length; i<l; i++) {
    var opt = new Option();
    for(var j in attr[i]) {
      switch(j) {
      case 'innerHTML':
        $(opt).html(attr[i][j]); break;
      case 'selected':
        opt.selected = opt.defaultSelected = attr[i][j]; break;
      case 'disabled':
        opt.disabled = attr[i][j]; break;
      case 'value':
      default:
        opt.setAttribute(j, attr[i][j]);
      }
    }
    $(sid).appendChild(opt);
  }
}

/* Возвращает value или innerHTML выбранной опции селектора */
function selOption(sid, what) {
  return $(sid).options[$(sid).selectedIndex][what ? 'innerHTML' : 'value'];
}

/* Делает красивую установку/удаление атрибута disabled для input type="checkbox" */
function setDisabled(chid, action) {
  var state = $(chid).disabled;
  if(action) {
    if(state) return false;
    $(chid).disabled = true;
    $($(chid).nextSibling).classAdd('grey');
  } else {
    if(!state) return false;
    $(chid).disabled = false;
    $($(chid).nextSibling).classRemove('grey');
  }
}

/* Возвращает массив чисел забитых мячей из строк результатов */
function getCount() {
  var results = [];
  for(var i=0,l=arguments.length; i<l; i++) results.push(arguments[i] ? arguments[i].match(/\^/g).length : 0);
  return results;
}

/* Определяет по числу дополнительный это матч или турнирный */
function matchType(num) {
  var pnum = parseInt(num, 10);
  return !!(((typeof num=='string' && num.length > 2) || pnum > $total[0] || pnum < 0) && pnum != -100);
}

/* Возвращает массив данных конкретной команды */
function getComData(c) { 
  var isGroup = $('group_div').firstChild;
  if(isGroup) {
    var grn = selOption('group', true);

    if(isGroup.disabled) { // ищем по всем подхэшам
      for(var i in data[$key]) if(i!='service' && i!='extra' && data[$key][i][c.toString()]) return data[$key][i][c.toString()];
    } else return data[$key][grn.replace(/\&nbsp;|\s+$/g, '')][c.toString()]; // ищем в хэше с ключом, равным названию группы
  } else return data[$key][c.toString()]; // ищем в главном и единственном хэше
}

/* Подготовка страницы в зависимости от наличия хэша данных */
function pagePrepare() {
  $('mmnu').empty(true, true);
  if(!objTools.length(data)) {
    $('first_start').show();
    $('main').hide();
    makeHeader('Первый запуск');
  } else {
    $('first_start').hide();

    for(var i in data) $('mmnu').add('li', {'class':'hds'}, [add('b', null, [addtext(i)])]);

    navi();
    tabs.init({apply:[        
      { hds : 'hds', open : $url.champ, callback : function(a,b,c) {
        $url.champ = c;
        navi(true);
        $key = a.firstChild.html();
        loadData();
      }},
      { els : 'inner_els', hds : 'inner_hds', open : $url.tab, callback : function(a,b,c) {
        $url.tab = c;
        navi(true);
      }}
    ]});
    tabs.openTab(tabs.all[1], tabs.all[1].hds[$isResults ? 0 : 1]); // автооткрытие рабочей вкладки
    $('main').show();
  }
}

/* Загрузка данных на страницу по ключу */
function loadData() {
  var obj = data[$key], tn = 1, all_cn = [], tour = {}, nobj = {};

  $isResults = obj.service.results; // глобально запоминаем флаг результатов

  // Готовим блок ввода
  $('count_home').value = $('count_guest').value = $('count_home_ps').value = $('count_guest_ps').value = '0';
  $('group_div').empty(true, true);
  $('input_tour_div').empty(true, true);
  $('extra_group_span').empty(true, true);
  $('extra_group_span').show(); $('extra_group_inp').hide();
  if(!$isResults) {
    $('extra_ps_span').hide();
    $('extra_ps_div').hide();
  }

  try { $('count_home').focus(); } catch(err) {}
  $('match_add').disabled = true;
  $('bombs_input').empty(true, true);

  var showCommands = function(cobj, serv) { // сортирует хэш команд и выводит все данные в таблицу
    var newObj = {}, started = true, keys = [];

    for(var i in cobj) if(i!='service' && i!='extra') {
      var cd = cobj[i];
      if((cd[0] + cd[1] + cd[2])!=0) {
        started = false;
        $total[1] = false;
      }
      keys.push(i);
  
      var res = cd[6];
      for(var j in res) {
        if(!$results[j]) $results[j] = [];
        $results[j].push(i + '|' + res[j]);
      }
    }

    /* Сортируем данные по правилам распределения команд в турнирной таблице (взято из регламента Чемпионата России 2008 года).
       Выше располагается команда:
       1 - набравшая большее очков;
       2 - с большим числом побед во всех матчах;
       3 - с лучшими показателями по личным встречам**:
           3.1 - с большим числом очков,
           3.2 - с лучшей разницей мячей,
           3.3 - с большим числом забитых мячей,
           3.4 - с большим числом забитых мячей на чужом поле;
       4 - с лучшей разницей мячей во всех матчах;
       5 - с большим числом забитых мячей во всех матчах;
       6 - с большим числом забитых мячей на чужом поле во всех матчах**;
       7 - победившая в дополнительном матче***.

       **  - учитывается только при включённом сохранении результатов;
       *** - только для турниров с одной группой.
    */
    if(!started) keys.sort(function cmp(a, b) {
      var cr1_a = cobj[a][0]*3 + cobj[a][1], cr1_b = cobj[b][0]*3 + cobj[b][1]; // пункт 1
      if(cr1_a==cr1_b) {
        var cr2_a = cobj[a][0], cr2_b = cobj[b][0]; // пункт 2
        if(cr2_a==cr2_b) {
          var criteries = [];
          if($isResults) {
            var cr3 = {}; cr3[a] = [0, 0, 0, 0]; cr3[b] = [0, 0, 0, 0]; // [Очки, МЗ, МП, МЗ на чужом поле]
            var saveResult = function(hc, gc) { // готовит и записывает в промежуточный хэш данные для сравнений по пункту 3
              for(var i in cobj[hc][6]) {
                if(cobj[hc][6][i].find(gc)) {
                  var arr = cobj[hc][6][i].split('|'), rm = getCount(arr[1], arr[2]);

                  if(rm[0]>rm[1]) cr3[hc][0] += 3;
                  else if(rm[0]==rm[1]) {
                    cr3[hc][0]++; cr3[gc][0]++;
                  } else cr3[gc][0] += 3;

                  cr3[hc][1] += rm[0]; cr3[gc][2] += rm[0];
                  cr3[hc][2] += rm[1]; cr3[gc][1] += rm[1];
                  cr3[gc][3] += rm[1];
                }
              }
            };

            saveResult(a, b); saveResult(b, a);
            criteries.push([cr3[a][0], cr3[b][0]]); // пункт 3.1
            criteries.push([cr3[a][1] - cr3[a][2], cr3[b][1] - cr3[b][2]]); // пункт 3.2
            criteries.push([cr3[a][1], cr3[b][1]]); // пункт 3.3
            criteries.push([cr3[a][3], cr3[b][3]]); // пункт 3.4
          }

          criteries.push([cobj[a][3] - cobj[a][4], cobj[b][3] - cobj[b][4]]); // пункт 4
          criteries.push([cobj[a][3], cobj[b][3]]); // пункт 5

          for(var i=0,l=criteries.length; i<l; i++) {
            var cp = criteries[i];
            if(cp[0]!=cp[1]) return (cp[0] < cp[1]) ? 1 : -1;
          }

          if($isResults) {
            var cr6_a = 0, cr6_b = 0; // пункт 6
            for(var i in $results) {
              for(var j=0,l=$results[i].length; j<l; j++) {
                var arr = $results[i][j].split('|');
                if(arr[1]==a) cr6_a += getCount(arr[3])[0];
                if(arr[1]==b) cr6_b += getCount(arr[3])[0];
              }
            }

            if(cr6_a==cr6_b) {
              if(!cobj.extra) return 0; // пропускаем пункт, если турнир с несколькими группами

              var cr7_a = 0, cr7_b = 0; // пункт 7
              for(var i in cobj.extra) {
                for(var j=0,l=cobj.extra[i].length; j<l; j++) {
                  var arr = cobj.extra[i][j];
                  if(arr.find(a) && arr.find(b)) {
                    var res = arr.split('|'), rm = getCount(res[2], res[3]), ps = res[4] ? res[4].split(':') : [0, 0];
                    if(res[0]==a) {
                      cr7_a += rm[0]; cr7_b += rm[1];
                      cr7_a += parseInt(ps[0], 10); cr7_b += parseInt(ps[1], 10);
                    } else {
                      cr7_b += rm[0]; cr7_a += rm[1];
                      cr7_b += parseInt(ps[0], 10); cr7_a += parseInt(ps[1], 10);
                    }
                  }
                }
              }
              if(cr7_a==cr7_b) return 0; // заглушка на случай, если дополнительный матч еще не добавлен
              return (cr7_a < cr7_b) ? 1 : -1;
            }
            return (cr6_a < cr6_b) ? 1 : -1;
          }
        }
        return (cr2_a < cr2_b) ? 1 : -1;
      }
      return (cr1_a < cr1_b) ? 1 : -1;
    });
    for(var i=0,l=keys.length; i<l; i++) newObj[keys[i]] = cobj[keys[i]];

    // Рисуем шапку турнирной таблички
    $('tt').add('table', {'class':'z bord ieFix m10', 'width':'100%', 'id':'tt_table_' + tn}, [
      add('tbody', null, [
        add('tr', null, [
          add('th', {'innerHTML':'Место'}),
          add('th', {'width':'69%', 'innerHTML':'Команда'}),
          add('th', {'class':'c', 'innerHTML':'И'}),
          add('th', {'class':'c', 'innerHTML':'В'}),
          add('th', {'class':'c', 'innerHTML':'Н'}),
          add('th', {'class':'c', 'innerHTML':'П'}),
          add('th', {'class':'c', 'innerHTML':'Голы'}),
          add('th', {'class':'c', 'innerHTML':'Очки'})
        ])
      ])
    ]);

    // Выводим отсортированные команды в таблицу  
    var cn = 1;
    for(var i in newObj) {
      if(i=='service' || i=='extra') continue;

      var el = newObj[i], svc = serv || cobj.service, cls = '', ttl = '';
  
      // Определяем, какой нынче тур идет
      var gn = el[0] + el[1] + el[2];
      if(!tour[gn]) tour[gn] = 0;
      tour[gn]++;
  
      // Подсвечиваем зоны еврокубков и вылета
      for(var j in svc) {
        if(j=='edited' || j=='results') continue;
        if(svc[j] && $(svc[j]).hasa(cn)!==false) {
          cls = j;
          ttl = typeof svc[j][0]=='string' ? svc[j][0] : $alias[j];
        }
      }
  
      // Добавляем команде заслуги прошлого сезона
      var icons = [];
      if(el[7]) {
        for(var j=0,l=el[7].length; j<l; j++) {
          var item = el[7][j];
          icons.push(add('img', {'align':'top', 'alt':$alias[item][0], 'title':$alias[item][0], 'style':'padding-left:5px', 'src':$alias[item][1]}));
        }
      }
  
      $($('tt_table_' + tn).firstChild).add('tr', (cn % 2 == 0) ? {'class':'hl'} : null, [
        add('td', {'class':cls, 'title':ttl, 'innerHTML':String(cn)}),
        add('td', {'class':'nc bb', 'innerHTML':i}, (icons.length != 0) ? icons : null),
        add('td', {'innerHTML':String(gn)}),
        add('td', {'innerHTML':String(el[0])}),
        add('td', {'innerHTML':String(el[1])}),
        add('td', {'innerHTML':String(el[2])}),
        add('td', {'noWrap':'noWrap', 'innerHTML':el[3] + ' &mdash; ' + el[4]}),
        add('td', {'class':'bb', 'innerHTML':String(el[0]*3 + el[1])})
      ]);
      cn++;
    }
    all_cn.push(cn);
    tn++;

    return newObj;
  };

  // Обрабатываем данные и запускаем функцию их сортировки и вывода в таблицу
  $results = {}; $total[1] = true;
  $('tt').empty(true, true);

  var gcn = 1, list = {};
  for(var i in obj) if(i!='service' && i!='extra') {
    var cd = obj[i];

    if('length' in cd) {
      nobj = showCommands(obj);
      if(obj.extra) nobj.extra = obj.extra;
      if(obj.service) nobj.service = obj.service;
      data[$key] = nobj; // обновляем весь глобальный хэш
      list = data[$key];
      break;
    } else {
      $('tt').add('h3', {'innerHTML':i});

      // Формируем селектор выбора группы
      var gr = $('group_div'), grn = !!(gcn == $url.group);
      if(!gr.firstChild) {
        gr.classAdd('m15');
        gr.add('select', {'id':'group'}).$('change', function(e) {
          var sel = e.target || e.srcElement,
              sHTML = selOption(sel, true);

          // Перезаполняем селекторы с командами
          createComsSelectors(data[$key][sHTML.replace(/\&nbsp;|\s+$/g, '')]);
          inputHandler('com_home');

          // Меняем переменную в урле
          $url.group = selOption(sel);
          navi(true);
        });
      }
      addOption($('group'), [{'value':gcn, 'innerHTML':i + '&nbsp;&nbsp;', 'selected':grn}]);
      gcn++;

      nobj = showCommands(cd, obj.service);
      data[$key][i] = nobj; // обновляем часть глобального хэша
      if(grn) list = data[$key][i];
    }
  }

  // Пишем заголовок
  makeHeader($key);

  // Дописываем текущий тур или стадию дополнительных матчей в заголовок
  var keys = [];
  for(var i in tour) keys.push(i);
  keys.sort(function cmp(a, b) {
    if(tour[a]==tour[b]) return 0;
    return (tour[a] > tour[b]) ? -1 : 1;
  });
  var last = (getMax(all_cn) - 1) * 2 - 2, finished = (keys[0] == last && keys.length == 1);
  $total[2] = finished;
  if(keys[0]!=0) $('hdr').innerHTML += ' :: ' + (finished ? (obj.extra && objTools.key(obj.extra).split('|')[0] > last ? objTools.key(obj.extra).split('|')[1] : 'Итоговая таблица') : 'после ' + keys[0] + ' тура'); else {
    if(obj.extra) $('hdr').innerHTML += ' :: ' + objTools.lastKey(obj.extra).split('|')[1];
  }

  // Заполняем селектор ввода тура и примерно определяем тур, выбранный для ввода по умолчанию
  if($isResults) {
    var extraManual = function(sid, action) { // включает ручной ввод названия стадии дополнительного матча
      if(action) {
        if(suilib.client.safari) $(sid).selectedIndex = $(sid).length - 1; else $(sid)[$(sid).length - 1].selected = $(sid)[$(sid).length - 1].defaultSelected = true;
        $($(sid).parentNode).hide();
        $(sid + '_inp').show();
        try { $(sid + '_inp').focus(); } catch(err) {};
      }
      extraHandler('extra');
    };

    var next = keys[0] == last ? keys[0] : getMin(keys) + 1;

    $('input_tour_div').classAdd('m15');
    $('input_tour_div').add('span', {'class':'bb', 'innerHTML':'Матч тура:&nbsp;&nbsp;'}, [
      add('select', {'id':'input_tour'})
    ]);
    $('extra_block').show();
    $('extra_group_span').add('select', {'id':'extra_group'}).$('change', function(e) {
      var sel = e.target || e.srcElement;
      extraManual(sel.id, selOption(sel)=='add');
    });

    // Сортируем хэш с результатами по убыванию туров
    if(obj.extra) {
      var tours = [], before = [], after= [], tr = {};
      for(var i in obj.extra) {
        var num = parseInt(i, 10), parsed = i.split('|');
        $extra_names[num] = parsed[1];
        tours.push(num);
      }
      tours.sort(function cmp(a, b) {
        if(a==b) return 0;
        return (a > b) ? -1 : 1;
      });
      for(var i=0,l=tours.length; i<l; i++) {
        var item = tours[i];
        if(item < 0) before.push(item); else after.push(item);
        var key = item + '|' + $extra_names[item];
        tr[key] = obj.extra[key];
      }
      data[$key].extra = tr;
    }

    // Добавляем сначала допматчи, сохранённые до туров
    if(obj.extra) for(var i=0; i<before.length; i++) addOption($('extra_group'), [{'value':before[i], 'class':'shl red', 'innerHTML':$extra_names[before[i]].toLowerCase() + '&nbsp;&nbsp;', 'selected':(before[i]==getMin(before) && $total[1] && !$total[2])}]);

    // Затем добавляем туры для переигровки
    for(var i=1; i<=last; i++) {
      addOption($('input_tour'), [{'value':i, 'innerHTML':String(i) + '&nbsp;&nbsp;', 'selected':i==next}]);
      addOption($('extra_group'), [{'value':i, 'innerHTML':'переигровка в ' + String(i) + ' туре&nbsp;&nbsp;', 'selected':(i==next && !$total[1] && !$total[2])}]);
    }

    // И в конце допматчи, сохранённые после туров
    if(obj.extra) for(var i=0; i<after.length; i++) addOption($('extra_group'), [{'value':after[i], 'class':'shl red', 'innerHTML':$extra_names[after[i]].toLowerCase() + '&nbsp;&nbsp;', 'selected':(after[i]==getMax(after) && $total[2] && !$total[1])}]);

    addOption($('extra_group'), [{'value':'add', 'class':'shl', 'innerHTML':'добавить новую&nbsp;&nbsp;'}]);
    if(($total[1] || $total[2]) && !obj.extra) extraManual('extra_group', true);
  } else {
    $('input_tour_div').classRemove('m15');
    $('extra_block').hide();
  }

  // Создаем и заполняем селекторы выбора команд + обновляем число игр в группе ($total[0])
  createComsSelectors(list);

  $empty = true;

  // Генерим таблицу результатов
  createResults();

  // Генерим таблицу бомбардиров
  var testOpts = function(opt, fs) { // на всякий случай проверяем опции из урла
    return typeof(opt)!='number' || opt < 0 || opt > (fs ? 1 : 2) ? 0 : opt;
  };
  createBombers(testOpts($url.bombs[0], true), testOpts($url.bombs[1]));

  // Когда же был последний сэйв?
  $('content').filter('div','instr',null,true).filter('b',null,null,true).walkwith(function(el) {
    el.html(obj.service.edited);
  });
}

/* Генерация таблицы результатов */
function createResults(tour) {
  var show = -100, tours = [], tr = {};

  // Добавляем в промежуточный глобальный хэш результаты дополнительных матчей
  $results = objTools.extend($results, data[$key].extra);

  // Рисуем шапочку и готовим селектор выбора тура и ссылки для печати
  $('rt').empty(true, true);
  $('r_tours_span').empty(true, true);
  $('r_tours_span').add('select', {'id':'r_tours', 'style':suilib.client.msie ? 'width:90px' : ''}).$('change', function(e) {
    var show = parseInt((e.target || e.srcElement).value);
    createResults(show);
  });
  var rsid = $('r_tours');
  $($('r_print').parentNode).show();
  $($('t_print').parentNode).hide();
  $('rt').add('table', {'class':'z bord ieFix m10', 'width':'100%', 'id':'rt_table'}, [
    add('tbody', null, [
      add('tr', null, [
        add('th', {'innerHTML':$isResults ? (objTools.length($results) ? '' : 'Не сыграно ни одного матча') : 'Сохранение результатов было отключено', 'colSpan':$isResults && objTools.length($results) ? '3' : ''})
      ])
    ])
  ]);

  if($isResults) {
    if(objTools.length($results)) {
      var matchName = function(num) { // возвращает строку для вывода полного названия тура по его номеру
        return ('Матчи ' + num + ' тура');
      };

      // Сортируем хэш с результатами по убыванию туров
      for(var i in $results) {
        var num = parseInt(i, 10);
        tours.push(num);
      }
      tours.sort(function cmp(a, b) {
        if(a==b) return 0;
        return (a > b) ? -1 : 1;
      });
      for(var i=0,l=tours.length; i<l; i++) {
        var item = tours[i], key = $results[item] ? item : item + '|' + $extra_names[item];
        tr[item] = $results[key];
      }
      $results = tr;

      // Заполняем селектор выбора тура с учетом взятого из урла или автоматически выбранного исходного тура
      show = String(tour || ($results[$url.tour] || $url.tour=='-100' ? $url.tour : (tours[0] || 1)));
      for(var i in $results) addOption(rsid, [{'value':i, 'innerHTML':(matchType(i) ? $extra_names[i].toLowerCase() : 'тур ' + i) + '&nbsp;&nbsp;', 'class':matchType(i) ? 'shl red' : '', 'selected':i==show}]);

      // Пишем заголовок таблицы
      $('rt_table').filter('th', null, null, true)[0].innerHTML = matchType(show) ? $extra_names[show] : (show=='-100' ? (matchType(tours[0]) ? $extra_names[tours[0]] : matchName(tours[0])) : matchName(show));

      // Меняем переменную в урле
      $url.tour = show;
      navi(true);

      // Добавляем нужные результаты в табличку
      var restorated = function(str) { // восстанавливает в читабельный вид строчку бомбардиров
        return str ? str.replace(/(\^[^,]+)/g, ' ($1)').replace(/\,/g, ', ').replace(/\^((\d|\+)+)/g, '$1\', ').replace(/, @|@/g, ' - автогол, ').replace(/, %|%/g, ' - с пенальти, ').replace(/,\ ?\)/g, ')') : '&mdash;';
      };
      var writeTour = function(what) { // выводит тур в таблицу
        for(var i=0,l=what.length; i<l; i++) {
          var mtch = what[i].split('|'), counts = getCount(mtch[2], mtch[3]), ps = mtch[4] ? mtch[4].replace(/\:/, ' : ') : false;

          $($('rt_table').firstChild).add('tr', {'class':'hl'}, [
            add('td', {'width':'49%', 'class':'r bb', 'innerHTML':mtch[0]}),
            add('td', {'noWrap':'noWrap', 'innerHTML':counts[0].toString() + ' : ' + counts[1].toString() + (ps ? ('<br /><b>(' + ps + ')</b>') : '')}),
            add('td', {'width':'49%', 'class':'l bb', 'innerHTML':mtch[1]})
          ]);
    
          $($('rt_table').firstChild).add('tr', null, [
            add('td', {'class':'r', 'innerHTML':restorated(mtch[2])}),
            add('td'),
            add('td', {'class':'l', 'innerHTML':restorated(mtch[3])})
          ]);
        }
      };

      if(show=='-100') {
        for(var i in $results) {
          if($('rt_table').firstChild.lastChild.firstChild.tagName!=='TH') {
            $($('rt_table').firstChild).add('tr', null, [
              add('th', {'innerHTML':matchType(i) ? $extra_names[i] : matchName(i), 'colSpan':'3'})
            ]);
          }
          writeTour($results[i]);
        }
      } else writeTour($results[show]);
    }
    addOption(rsid, [{'value':'-100', 'innerHTML':'все&nbsp;&nbsp;', 'selected':show=='-100'}]);
  } else {
    addOption(rsid, [{'value':'null', 'innerHTML':'нет данных&nbsp;&nbsp;'}]);
    $($('r_print').parentNode).hide();
    $($('t_print').parentNode).show();
  }
}

/* Генерация таблицы бомбардиров

   type - тип таблицы для вывода (0 - по голам, 1 - по командам)
   sorting - сортировка (0 - по фамилии, 1 - по командам (только для type = 0), 2 - по голам (только для type = 1))
*/
function createBombers(type, sorting) {
  var obj = data[$key], fullObj = {}, nobj = {}, newObj = {}, cn = 1;

  // Готовим селекторы
  var opts = $('b_sorts').options, types = $('b_types').options, sel = opts[(type == 0) ? 2 : 1].selected ? 0 : sorting;
  types[type].selected = types[type].defaultSelected = true;
  opts[sel].selected = opts[sel].defaultSelected = true;
  opts[1].disabled = (type == 0) ? false : true;
  opts[2].disabled = (type == 0) ? true : false;

  // Меняем переменную в урле
  $url.bombs = [type, sel];
  navi(true);

  // Сортируем и переформировываем данные в соответствие с выбранным способом отображения
  // и создаем таблицу в соответствие с выбранным типом
  $('bt').empty(true, true);
  $('content').filter('div','instr',null,true).filter('div','pages',null,true).walkwith(function(el) {
    el.html('В скобках указаны голы, забитые с пенальти');
  });

  // Сортируем бомбардиров каждой команды по фамилии или забитым мяча (=> newObj (полный отсортированный клон data[$key]) для использования при type = 1)
  // Код вынесен сюда, чтобы по фамилии сортировалось всегда при первом выводе (надо для селектора списка бомбардиров)
  var s = (sorting == 2) ? true : false;
  var sortBombers = function(cobj) {
    newObj = objTools.clone(cobj);
    for(var i in cobj) {
      if(i=='service' || i=='extra') continue;
      var keys = [], bombs = cobj[i][5];
      if(objTools.length(bombs)) {
        $empty = false;
        newObj[i][5] = {};
        for(var j in bombs) {
          keys.push(j);
        }
    
        keys.sort(function cmp(a, b) {
          if(s) {
            a = bombs[a][0];
            b = bombs[b][0];
          }
          if(a==b) return 0;
          return (a < b) ? (s ? 1 : -1) : (s ? -1 : 1);
        })
    
        for(var j=0,l=keys.length; j<l; j++) {
          newObj[i][5][keys[j]] = bombs[keys[j]];
        }
      }
    }

    return newObj;
  };

  // Обрабатываем данные и запускаем функцию их сортировки => на выходе получаем хэш fullObj (либо клон data[$key], либо объединение команд из всех групп)
  for(var i in obj) if(i!='service' && i!='extra') {
    var cd = obj[i];

    if('length' in cd) {
      nobj = sortBombers(obj);
      fullObj = nobj;
      if(!s) data[$key] = nobj; // обновляем весь глобальный хэш
      break;
    } else {
      nobj = sortBombers(cd);
      fullObj = objTools.extend(fullObj, nobj);
      if(!s) data[$key][i] = nobj; // обновляем часть глобального хэша
    }
  }

  switch(type) {
  case 1:
    // Бомбардиров нет
    if($empty) {
      $('bt').add('table', {'class':'z bord ieFix m10', 'width':'100%'}, [add('tbody', null, [add('tr', null, [add('th', {'innerHTML':'Голов пока никто не забивал'})])])]);
      $('content').filter('div','instr',null,true).filter('div','pages',null,true).walkwith(function(el) {
        el.html(' ');
      });
      break;
    }

    // Рисуем шапочку
    $('bt').add('table', {'class':'z bord ieFix m10', 'width':'100%', 'id':'bt_table'}, [
      add('tbody', null, [
        add('tr', null, [
          add('th', {'innerHTML':'Команды'}),
          add('th', {'width':'99%', 'innerHTML':'Бомбардиры'})
        ])
      ])
    ]);

    // Выводим отсортированных бомбардиров по командам
    for(var i in fullObj) {
      if(i=='service' || i=='extra') continue;

      var el = fullObj[i], tempObj = {}, isBombs = objTools.length(fullObj[i][5]), auto = 0;
      if(isBombs) {
        for(var j in el[5]) {
          var cur = el[5][j], fst = el[5][j][0];
          if(typeof cur[1]=='string') auto = auto + fst;
          else {
            if(s) {
              if(!tempObj[fst]) tempObj[fst] = [];
              tempObj[fst].push([j, cur[1]]);
              tempObj[fst].sort();
            }
          }
        }
        if(objTools.length(tempObj)) el[5] = tempObj;
      }

      var a = (auto == 0) ? true : false;
      $($('bt_table').firstChild).add('tr', (cn % 2 == 0) ? {'class':'hl'} : null, [
        add('td', {'class':'nc', 'vAlign':'top'}, [
          add('div', {'class':'m5 bb', 'innerHTML':i}),
          add('div', {'innerHTML':'Всего забито: ' + '<b>' + String(el[3]) + '</b>'},
            a ? null : [add('div', {'class':'s11', 'innerHTML':' (из них автоголов: <b>' + String(auto) + '</b>)'})])
        ]),
        add('td', {'class':'l', 'id':'bombs_list_'+cn})
      ]);

      if(isBombs)
        for(var j in el[5]) {
          var cur = el[5][j];
          if(typeof cur[1]=='string') continue;
          if(s) {
            var formatted = cur.walkwith(function(el) {
              return String(el[0] + (el[1] == 0 ? '' : ' (' + el[1] + ')'));
            });
          }
          $('bombs_list_'+cn).add('div', {'class':'m5', 'innerHTML':(s ? '<b>' : '') + String(j) + ' &mdash; ' + (s ? '</b>' : '') + (s ? formatted.join(', ') : '<b>' + String(cur[0]) + (cur[1] == 0 ? ' ' : ' (' + String(cur[1]) + ') ') + '</b>')});
        }
      cn++;
    }
  break;

  case 0:
  default:
    // Сортируем бомбардиров всех команд по забитым мячам и фамилии или команде => newObj (абсолютно новый отсортированный хэш с ключами = забитые мячи + auto)
    var newObj = {}, tempObj = {}, keys = [], s = (sorting == 1) ? true : false;
    for(var i in fullObj) {
      if(i=='service' || i=='extra') continue;
      var el = fullObj[i][5];
      if(objTools.length(el))
      for(var j in el) {
        var bd = el[j], ss = (typeof el[j][1] == 'string');
        var key = ss ? 'auto' : bd[0];
        var ba = [j, ss ? bd[0] : bd[1], ss ? bd[1] : i];
        if(!ss) keys.push(parseInt(key, 10));
        if(!newObj[key]) newObj[key] = [];
        newObj[key].push(ba);
      }
    }

    // Бомбардиров нет
    if($empty) {
      $('bt').add('table', {'class':'z bord ieFix m10', 'width':'100%'}, [add('tbody', null, [add('tr', null, [add('th', {'innerHTML':'Голов пока никто не забивал'})])])]);
      $('content').filter('div','instr',null,true).filter('div','pages',null,true).walkwith(function(el) {
        el.html(' ');
      });
      break;
    }

    if(objTools.length(newObj)) {
      keys.sort(function cmp(a, b) {
        if(a==b) return 0;
        return (a < b) ? 1 : -1;
      })

      for(var i=0,l=keys.length+1; i<l; i++) {
        var arr = newObj[keys[i]] ? keys[i] : 'auto';
        if(!newObj[arr]) continue;
        newObj[arr].sort(function cmp(a, b) {
          var p1 = s ? a[2] : a[0], p2 = s ? b[2] : b[0];
          if(p1==p2) {
            if(a[0]==b[0]) return 0;
            return (a[0] < b[0]) ? -1 : 1;
          }
          return (p1 < p2) ? -1 : 1;
        })
        tempObj[arr] = newObj[arr];
      }
      newObj = tempObj;
    }

    // Рисуем шапочку
    $('bt').add('table', {'class':'z bord ieFix m10', 'width':'100%', 'id':'bt_table'}, [
      add('tbody', null, [
        add('tr', null, [
          add('th', {'class':'c', 'innerHTML':'Голы'}),
          add('th', {'width':'99%', 'innerHTML':'Игроки'})
        ])
      ])
    ]);

    // Выводим отсортированных бомбардиров по голам
    for(var i in newObj) {
      var a = (i == 'auto') ? true : false;

      // Объединяем лузеров, забивших автоголы разным командам
      if(a) {
        var tmp = {};
        for(var j=0; j<newObj[i].length; j++ ) {
          if(tmp[newObj[i][j][0]]==null) tmp[newObj[i][j][0]] = j;
          else {
            newObj[i][tmp[newObj[i][j][0]]][1] += newObj[i][j][1];
            newObj[i].splice(j, 1);
            j--;
          }
        }
        $autogoals = newObj[i]; // сохраняем в глобальный массив всех, кто забивал автоголы
      }

      var formatted = newObj[i].walkwith(function(el) {
        return String(el[0] + ' (' + el[2] + (el[1] !== 0 ? (a && el[1] == 1 ? '' : ', ' + el[1]) : '') + ')');
      });

      $($('bt_table').firstChild).add('tr', (cn % 2 == 0) ? {'class':'hl'} : null, [
        add('td', {'class':'bb', 'vAlign':'top', 'innerHTML':a ? 'в свои ворота' : i}),
        add('td', {'class':'l', 'innerHTML':formatted.join(', ')})
      ]);
      cn++;
    }
  }
}

/* Создание селекторов выбора команды */
function createComsSelectors(list, isGroups, ehCall) {
  $('com_home_span').empty(true, true);
  $('com_guest_span').empty(true, true);
  $('com_home_span').show(); $('com_home_inp').hide();
  $('com_guest_span').show(); $('com_guest_inp').hide();

  // Заполняем первый селектор
  $('com_home_span').add('select', {'id':'com_home'}).$('change', inputHandler);
  addOption('com_home', [{'value':'null', 'innerHTML':'Выберите команду&nbsp;&nbsp;', 'selected':true}]);
  var cn = 0;
  for(var i in list) {
    if(i=='service' || i=='extra') continue;
    addOption('com_home', [{'value':i, 'innerHTML':i + '&nbsp;&nbsp;'}]);
    cn++;
  }
  if(isGroups) addOption('com_home', [{'value':'add', 'class':'shl', 'innerHTML':'Новая команда&nbsp;&nbsp;'}]);

  // Клонируем второй
  var node = $('com_home').cloneNode(true);
  node.setAttribute('id', 'com_guest');
  node.$('change', inputHandler);
  $('com_guest_span').appendChild(node);

  // Сбрасываем экстра-блок, только если функцию вызвал не extraHandler()
  if(!isGroups) {
    if(!ehCall) {
      setDisabled('extra_save', true);
      if($isResults && $('extra').checked) {
        $('extra').checked = false;
        $('extra_ps').checked = false;
        $('extra_ps_span').show();
        extraHandler('extra');
      }
    }

    $total[0] = cn * 2 - 2; // обновляем число игр в группе, чтобы проверки были корректны
  }
}

/* Создание списка ввода бомбардиров и обработка смены его селекторов */
function createBombsList() {
  var list = {}, cn = 1, hv = parseInt($('count_home').value, 10), gv = parseInt($('count_guest').value, 10),
      hs = selOption('com_home') == 'add' ? $('com_home_inp').value : selOption('com_home'),
      gs = selOption('com_guest') == 'add' ? $('com_guest_inp').value : selOption('com_guest');

  // Очищаем и подготавливаем блок бомбардиров
  $('bombs_input').empty(true, true);
  if(hv + gv <= 0) return null;
  $('bombs_input').add('div', {'class':'m5 bb', 'innerHTML':'Голы забили:'});
  $('bombs_input').add('ol', {'id':'bombs_list'});

  // Добавляем элементы списка
  for(var i=0,l=hv+gv; i<l; i++) {
    list[cn] = (i < hv) ? hs : gs;
    cn++;
  }

  for(var i in list) {
    var sn = (list[i] == hs) ? 0 : 1, cid = 'bombs_comms_' + i, pid = 'bombs_players_' + i;
    $('bombs_list').add('li', null, [
      add('div', {'class':'m5'}, [
        add('select', {'id':pid}).$('change',
          function(e) {
            // Обработчик выбора ввода нового игрока
            var slc = e.target || e.srcElement;
            if(selOption(slc)=='add') {
              var inp = $(slc.id + '_inp');
              $(slc).hide();
              inp.show();
              try { inp.focus(); } catch(err) {};
            }
          }),
        add('input', {'type':'text', 'size':'30', 'id':pid + '_inp'}).hide().$(suilib.client.opera ? 'keypress' : 'keyup',
          function(e) {
            // Отмена ввода нового игрока по нажатию ESC
            var inp = e.target || e.srcElement;
            if(e.keyCode==27 && inp.previousSibling && inp.previousSibling.options.length!=0) {
              $(inp.previousSibling).show();
              $(inp).hide();
            }
          })
      ]),
      add('div', {'class':'m10', 'innerHTML':'из команды&nbsp;&nbsp;'}, [add('select', {'id':cid}).$('change',
        function(e) {
          // Перезаполняем селектор при смене команды
          var sid = (e.target || e.srcElement).id;
          var bid = 'bombs_players_' + sid.substr(sid.length - 1), pid = $('bombs_penalty_' + sid.substr(sid.length - 1)), aid = $('bombs_auto_' + sid.substr(sid.length - 1));

          while($(bid).options.length) $(bid).remove($(bid).options.length - 1);
          insertBombs(bid, selOption(sid));
          if(aid.style.display=='none') {
            aid.show();
            if(pid.checked) pid.checked = false;
            setDisabled(pid, true);
          } else {
            aid.hide();
            setDisabled(pid, false);
          }
        })
      ]),
      $isResults ?
      add('div', {'class':'m10', 'innerHTML':'на&nbsp;&nbsp;'}, [
        add('input', {'type':'text', 'size':'2', 'id':'bombs_time_' + i}),
        add('span', {'innerHTML':'&nbsp;&nbsp;минуте'})
      ]) : null,
      add('div', {'class':'m5'}, [
        add('input', {'type':'checkbox', 'class':'chk', 'id':'bombs_penalty_' + i}),
        add('label', {'for':'bombs_penalty_' + i, 'innerHTML':'с пенальти'}),
        add('span', {'id':'bombs_auto_' + i}, [
          add('input', {'type':'checkbox', 'disabled':'disabled', 'checked':'checked', 'class':'chk', 'style':'margin-left:15px'}),
          add('label', {'class':'red', 'innerHTML':'в свои ворота'})
        ]).hide()
      ])
    ]);

    addOption(cid, [
      {'value':hs, 'innerHTML':hs + '&nbsp;&nbsp;'},
      {'value':gs, 'innerHTML':gs + '&nbsp;&nbsp;'}
    ]);
    $(cid).options[sn].selected = $(cid).options[sn].defaultSelected = true;

    insertBombs(pid, list[i]);
  }
}

/* Заполняет селектор сохраненными бомбардирами нужной команды */
function insertBombs(sid, com) {
  var arr = getComData(com);
  var bombs = arr ? arr[5] : {},
      names = [], isAG = false;

  $(sid).show();
  $(sid + '_inp').hide();

  // Добавляем в массив фамилии бомбардиров команды
  for(var i in bombs) {
    if(typeof bombs[i][1]=='string') continue;
    names.push(i);
  }

  // Добавляем в массив фамилии авторов автоголов команды
  $($autogoals).walkwith(function(el) {
    if(el[2]==com.toString()) {
      isAG = true;
      names.push(el[0]);
    }
  });

  // Удаляем возможные дубликаты и сортируем фамилии, если для команды были найдены авторы автоголов
  if(isAG) {
    var tmp = {};
    for(var j=0; j<names.length; j++ ) {
      if(tmp[names[j]]==null) tmp[names[j]] = j;
      else {
        names.splice(j, 1);
        j--;
      }
    }
    names.sort();
  }

  // Заполняем селектор опциями
  $(names).walkwith(function(el) {
    addOption(sid, [{'value':el, 'innerHTML':el}]);
  });
  if(names.length!=0) addOption(sid, [{'value':'add', 'class':'shl', 'innerHTML':'Новый игрок&nbsp;&nbsp;'}]);

  // Скрываем селектор, если нет бомбардиров, авторов автоголов или сохранены только авторы автоголов из других команд
  if(names.length==0) {
    $(sid).hide();
    $(sid + '_inp').show();
  }
}

/* Модицифированный объект "Динамические вкладки" (оригинал портирован из SUILib v1.3.x) */
var tabs = {
  init: function(args) {
    if(!args.apply) return false;
    var allNodes = args.apply.length ? $(suilib.body).filter('*',null,null,true) : [];
    var len = allNodes.length;
    for(var i=0,l=args.apply.length; i<l; i++) {
      this.all[i] = {};
      if(!args.apply[i].els && !args.apply[i].hds) continue;
      if(typeof args.apply[i].els=='string') {
        var tmp = [];
        for(var j=0; j<len; j++)
          if(allNodes[j] && allNodes[j].className && allNodes[j].className.split(' ').hasa(args.apply[i].els)!==false)
            tmp.push(allNodes[j]);
        this.all[i].els = tmp;
      } else if(typeof args.apply[i].els=='object' && args.apply[i].els.length)
        this.all[i].els = args.apply[i].els;
      if(args.apply[i].hds) {
        if(typeof args.apply[i].hds=='string') {
          var tmp = [];
          for(var j=0; j<len; j++)
            if(allNodes[j] && allNodes[j].className && allNodes[j].className.split(' ').hasa(args.apply[i].hds)!==false)
              tmp.push(allNodes[j]);
          this.all[i].hds = tmp;
        } else if(typeof args.apply[i].hds=='object' && args.apply[i].hds.length)
          this.all[i].hds = args.apply[i].hds;
      }
      if(args.apply[i].open) {
        var what = this.all[i].els ? this.all[i].els : this.all[i].hds;
        if(typeof args.apply[i].open=='string')
          this.all[i].open = $(args.apply[i].open);
        else if(typeof args.apply[i].open=='number' && args.apply[i].open<=what.length)
          this.all[i].open = $(what[args.apply[i].open-1]);
      }
      this.all[i].callback = args.apply[i].callback || suilib.anonymous;
      this.buildTabs(this.all[i]);
    }
  },

  all: [],
  cls: ['tab', 'tab_act', 'tab_hover'],

  buildTabs: function(tArr) {
    var tHd = [], len = tArr.els ? tArr.els.length : tArr.hds.length;
    for(var i=0; i<len; i++) {
      var el = tArr.els ? $(tArr.els[i]) : null, hd = false;
      if(tArr.hds) hd = $(tArr.hds[i]); else {
        hd = el.filter('*',null,null,true)[0];
        el.parentNode.insertBefore(hd, $(tArr.els[0]));
        tHd.push(hd);
      }
      if(tArr.open && el==tArr.open) tArr.open = hd;
      if(el) el.hide();
    }
    if(!tArr.hds) tArr.hds = tHd;

    var handlerClick = [], handlerOver = [], handlerOut = [];
    for(var i=0,l=tArr.hds.length; i<l; i++) {
      handlerClick[i] = (function(){tabs.openTab(tArr, arguments.callee.obj);});
      handlerOver[i]  = (function(){var el = arguments.callee.obj, allCls = (el.className.split(' ') || []); if(allCls.hasa(tabs.cls[1])===false) el.classReplace('tab_hover', tabs.cls);});
      handlerOut[i]   = (function(){var el = arguments.callee.obj, allCls = (el.className.split(' ') || []); if(allCls.hasa(tabs.cls[1])===false) el.classReplace('tab', tabs.cls);});
      handlerClick[i].obj = handlerOver[i].obj = handlerOut[i].obj = tArr.hds[i];
      handlerClick[i].$('click', tArr.hds[i]);
      handlerOver[i].$('mouseover', tArr.hds[i]);
      handlerOut[i].$('mouseout', tArr.hds[i]);
    }

    this.openTab(tArr, tArr.open ? tArr.open : tArr.hds[0]);
  },

  openTab: function(tArr, tOpen) {
    var index = 0, tHd = tArr.hds;
    for(var i=0,l=tHd.length; i<l; i++) {
      var allCls = (tHd[i].className.split(' ') || []);
      if(tHd[i]==tOpen) {
        if(allCls.hasa(tabs.cls[1])!==false) return false;
        tHd[i].classReplace('tab_act', this.cls);
        index = i;
      } else {
        if(allCls.hasa(tabs.cls[0])!==false) continue;
        tHd[i].classReplace('tab', this.cls);
        if(tArr.els) $(tArr.els[i]).hide();
      }
    }
    var el = tArr.els ? tArr.els[index] : null;
    if(tArr.callback) tArr.callback(tHd[index], el, index+1);
    if(el) $(tArr.els[index]).show();
  }
}

/* Объект для работы с хэшами */
var objTools = {
  print: function(hash) {
    if(!hash || typeof(hash)!=='object') return null;
    return 'var data = ' + this.parse(hash) + ';';
  },
  $specialChars: {
    '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"' : '\\"', '\\': '\\\\'
  },
  $replaceChars: function(chr) {
    return this.$specialChars[chr] || '\\u00' + Math.floor(chr.charCodeAt() / 16).toString(16) + (chr.charCodeAt() % 16).toString(16);
  },
  parse: function(hash) {
    var self = this;
    switch(typeof(hash)) {
      case 'string':
        return "'" + hash.replace(/[\x00-\x1f\\"]/g, function(chr){ return self.$replaceChars.apply(self, [chr]); }) + "'";
      case 'number':
        return isFinite(hash) ? String(hash) : 'null';
      case 'object':
        if(hash===null) return String(hash);
        var string = [];
        if('length' in hash) {
          for(var i=0,l=hash.length; i<l; i++) {
            if(typeof hash[i]=='undefined') continue;
            string.push(this.parse(hash[i]));
          }
          return '[' + String(string) + ']';
          break;
        }
        for(var i in hash) {
          var json = this.parse(hash[i]);
          if(json) string.push(this.parse(i) + ':' + json);
        }
        return '{' + string + '}';
      default: return String(hash);
    }
    return null;
  },
  length: function(hash) {
    if(!hash || typeof(hash)!=='object') return null;
    var j = false;
    for(var i in hash) j++;
    return j;
  },
  clone: function(hash) {
    if(!hash || typeof(hash)!=='object') return hash;
    var newHash = hash.constructor();
    for(var i in hash) {
      newHash[i] = this.clone(hash[i]);
    }
    return newHash;
  },
  hash: function(hash) {
    if(!hash || !(hash instanceof Array)) return hash;
    if(hash.length==0) return {};
    var newHash = {};
    for(var i=0,l=hash.length; i<l; i++)
      newHash[i] = hash[i];
    return newHash;
  },
  key: function(hash) {
    if(!hash || typeof(hash)!=='object') return null;
    for(var key in hash)
      break;
    return key;
  },
  lastKey: function(hash) {
    if(!hash || typeof(hash)!=='object') return null;
    for(var key in hash);
    return key;
  },
  extend: function(hash, source_hash) {
    if(!hash || typeof(hash)!=='object') return null;
    for(var i in source_hash) hash[i] = source_hash[i];
    return hash;
  }
}


/*** Обработчики ***/

/*
  Глобальный универсальный обработчик элементов блока ввода данных
  АЛАРМ! На функцию много ссылок - с поправками лезть аккуратно
*/
function inputHandler(e) {
  var el = e.target || e.srcElement || $(e), isSel = !!(el.tagName === 'SELECT'), btn = $('match_add');
  var val = selOption(isSel ? el : 'com_home'),
      another = selOption(isSel ? (el.id == 'com_home' ? 'com_guest' : 'com_home') : 'com_guest');
  var hc = parseInt($('count_home').value, 10), gc = parseInt($('count_guest').value, 10),
      hps = parseInt($('count_home_ps').value, 10), gps = parseInt($('count_guest_ps').value, 10);

  if(isSel && val!='add' && val==another) { // защита от дурака о_О
    if(!btn.disabled) {
      btn.disabled = true;
      $('bombs_input').empty(true, true);
    }
    el[0].selected = el[0].defaultSelected = true;
    return false;
  }

  // Переключаемся на ввод новой команды
  if(isSel && val=='add') {
    var inp = $(el.id + '_inp');
    $(el).hide();
    inp.show(); inp.value = '';
    try { inp.focus(); } catch(err) {};
  }

  btn.disabled = true;
  $('bombs_input').empty(true, true);

  // Все проверки (если прошли - то включаем кнопку "Добавить матч" и пробуем создать блок ввода бомбардиров)
  if(val=='null' || another=='null' || isNaN(hc) || isNaN(gc) || hc < 0 || gc < 0) return false;
  if($isResults && $('extra_ps').checked && (hc!=gc || isNaN(hps) || isNaN(gps) || hps < 0 || gps < 0 || hps==gps)) return false;
  if(selOption('com_home')=='add' && ($('com_home_inp').style.display=='none' || $('com_home_inp').value=='')) return false;
  if(selOption('com_guest')=='add' && ($('com_guest_inp').style.display=='none' || $('com_guest_inp').value=='')) return false;
  btn.disabled = false;
  createBombsList();
}

/*
  Глобальный обработчик активации/деактивации блока дополнительного матча
  АЛАРМ! На функцию много ссылок - с поправками лезть аккуратно
*/
function extraHandler(e) {
  var chk = e.target || e.srcElement || $(e), active = chk.checked, ch = 'com_home', cg = 'com_guest',
      es = 'extra_save', eg = 'extra_group_div', ep = 'extra_ps', eps = 'extra_ps_span', epsd = 'extra_ps_div',
      extra_group = (selOption('extra_group') == 'add' && $('extra_group_inp').style.display != 'none') || (selOption('extra_group') != 'add' && matchType(selOption('extra_group')));

  setDisabled(es, active && extra_group ? false : true);
  $(es).checked = active && extra_group ? false : true;
  setDisabled(ep, extra_group ? false : true);
  $(ep).checked = false;
  if(!extra_group) $(epsd).hide();
  $('input_tour').disabled = active ? true : false;

  var createNC = function(action) { // добавляет или удаляет в селекторах опцию "Новая команда"
    if(!document.getElementById(ch)) return false;

    var nc = 'Новая команда',
        lastItem = $(ch)[$(ch).options.length - 1].html().replace(/\&nbsp;|\s+$/g, '');
    if(action && lastItem!=nc) {
      var opts = [{'value':'add', 'class':'shl', 'innerHTML':nc+'&nbsp;&nbsp;'}];
      addOption(ch, opts); addOption(cg, opts);
    }
    else if(!action && lastItem==nc) {
      $(ch).remove($(ch).options.length - 1);
      $(cg).remove($(cg).options.length - 1);
    }
  };
  var modifyComs = function(action) { // включает или отключает селектор выбора группы и перезаполняет селекторы выбора команд
    if(!$('group_div').firstChild) return false;
    if(action) {
      $('group').disabled = true;

      var temp = {}, all = {}, keys = [];
      for(var i in data[$key]) if(i!='service' && i!='extra') temp = objTools.extend(temp, data[$key][i]);
      for(var i in temp) keys.push(i);
      keys.sort();
      for(var i=0,l=keys.length; i<l; i++) all[keys[i]] = temp[keys[i]];

      createComsSelectors(all, true);
      inputHandler('com_home');
    } else {
      $('group').disabled = false;

      var grn = selOption('group', true);
      createComsSelectors(data[$key][grn.replace(/\&nbsp;|\s+$/g, '')], false, true);
      inputHandler('com_home');
    }
  };
  createNC(extra_group);

  if(active) {
    modifyComs(extra_group);

    if($(eps).style.display!='none') return null;
    $(eg).animate(.35, {height:[0, 35]}, function() {
      createNC(extra_group);
      $(eps).show();
    });
  } else {
    if($(eps).style.display=='none') return null;

    $(eg).animate(.35, {height:[35, 0]}, function() {
      modifyComs(false);
      createNC(false);
      $(eps).hide(); $(epsd).hide();

      var backup = function(sid) {
        $(sid).show();
        $(sid + '_inp').hide();
      };
      backup(ch); backup(cg);
      inputHandler(ch);
    });
  }
}

/* DOMContentLoaded */
suilib.ready(function() {
  pagePrepare();

  // Скрытие/раскрытие левого блока
  (function(e) {
    var left = $('menu'), right = $('content'), all = $('all'), btn = e.target || e.srcElement;
    if(btn.className=='toggler') {
      left.animate(.5, {width:[315, 5]}, function() {
        all.hide();
        left.style.paddingLeft = 0;
        right.style.marginLeft = '5px';
        btn.classAdd('open');
      });
    } else {
      left.animate(.5, {width:[5, 315]}, function() {
        all.show();
        left.style.paddingLeft = '15px';
        right.style.marginLeft = '330px';
        btn.classRemove('open');
      });
    }
  }).$('click', 'toggler');

  // Печать статистики
  (function(e) {
    e.returnValue = false;
    if(e.preventDefault) e.preventDefault();

    window.print();
  }).$('click', 'r_print', 't_print');

  // Создаем турнир(ы)
  (function() {
    if(objTools.length(data)) pagePrepare(); else alert('Запуск невозможен: не создан ни один турнир!');
  }).$('click', 'sys_load');
  (function() {
    var ol = objTools.length(data);
    if(ol) {
      if(confirm('Создано: '+ol+' турнир(ов). Вы действительно хотите сбросить их?')) {
        data = {};
        alert('Все данные удалены: можно начинать сначала!');
      }
    } else alert('Действие невозможно: данные не созданы или уже были удалены!');
  }).$('click', 'data_reset');
  (function(e) {
    var name = $('trn_name').value, inp = e.target || e.srcElement;
    var groups = $('groups').filter('div', 'commands_container', null, true);

    var saveGroup = function(gn) { // возвращает хэш данных одной группы для сохранения
      var coms = [], hash = {};
      $(groups)[gn].filter('input', null, {'type':'text'}, true).walkwith(function(el) {
        var val = el.value;
        if(val) coms.push(val);
      });

      if(coms.length < 2) {
        alert('Для сохранения необходимо назвать все команды!');
        delete data[name];
        return false;
      }

      for(var i=0,l=coms.length; i<l; i++) {
        hash[coms[i]] = [0, 0, 0, 0, 0, {}, {}];

        if($('champ_'+gn+'_'+i).checked) { // у команды есть статусы?
          if(!hash[coms[i]][7]) hash[coms[i]][7] = [];
          hash[coms[i]][7].push('champ');
        }
        if($('cup_'+gn+'_'+i).checked) {
          if(!hash[coms[i]][7]) hash[coms[i]][7] = [];
          hash[coms[i]][7].push('cup');
        }
        if($('new_'+gn+'_'+i).checked) {
          if(!hash[coms[i]][7]) hash[coms[i]][7] = [];
          hash[coms[i]][7].push('new');
        }
      }

      return hash;
    };

    var org = inp.value;
    inp.value = 'Сохраняем...';
    setTimeout(function(){ inp.value = org; }, 500);

    if(!name) {
      alert('Для сохранения необходимо дать название турниру!');
      return false;
    }
    data[name] = {};
    if(groups.length==1) {
      var hash = saveGroup(0);
      if(!hash) return false;
      data[name] = hash;
    } else {
      for(var i=0; i<groups.length; i++) {
        if(!$('group_'+i).value) {
          alert('Для сохранения необходимо назвать все группы!');
          delete data[name];
          return false;
        }
        var hash = saveGroup(i);
        if(!hash) return false;
        data[name]['Группа ' + $('group_'+i).value] = hash;
      }
    }

    // Заполняем служебный хэш
    data[name].service = {};
    data[name].service.edited = currentTime();
    data[name].service.results = $('trn_results').checked;
    $('zones').filter('input', null, {'type':'checkbox'}, true).walkwith(function(el) { // подсвечивать зоны?
      if(el.checked) {
        var sv = el.id.split('_'),
            txt = $(sv[0]+'_text').value != $alias[sv[0]];
        if(!data[name].service[sv[0]]) {
          data[name].service[sv[0]] = [];
          if(txt) data[name].service[sv[0]].push($(sv[0]+'_text').value);
        }
        data[name].service[sv[0]].push(parseInt(sv[1], 10));
      }
    });
  }).$('click', 'trn_save');
  (function() {
    $('trn').reset();
    $('groups').empty(true, true);
  }).$('click', 'trn_reset');
  (function(e) {
    var num = parseInt($('groups_num').value, 10), cn = parseInt($('commands_num_0').value, 10);
    $('groups').empty(true, true);
    if(isNaN(num) || num < 1 || isNaN(cn) || cn < 2) return false;

    var chkHandler = function(e) { // обработчик чекбоксов подсветок зон
      var chk = e.target || e.srcElement,
          arr = chk.id.split('_'),
          all = ['lch', 'le', 'out'];

      $(all).walkwith(function(el) {
        if(el!=arr[0]) {
          var trg = $(el+'_'+arr[1]);
          trg.checked = false;
          setDisabled(trg, chk.checked);
        }
      });
    };

    var createComs = function(e) { // создаёт команды в группах
      var inp = e.target || e.srcElement || $(e);
      var cn = parseInt(inp.value, 10),
          bn = parseInt(inp.id.substr(inp.id.length - 1), 10);

      bn = bn==0 ? 0 : bn - 1;
      var cb = $('commands_'+bn), old_cn = cb.filter('div', 'block', null, true);
      cb.empty(true, true);
      if(isNaN(cn) || cn < 2) cn = old_cn.length;

      // Вычисляем максимальное количество команд во всех группах
      var nums = [];
      $('groups').filter('input', 'commands_nums', null, true).walkwith(function(el) {
        nums.push(el.value);
      });

      var stimg = function(name) { // возвращает картинку с подсказкой для выбора статуса команды
        return [add('img', {'align':'top', 'alt':$alias[name][0], 'title':$alias[name][0], 'style':'padding-right:10px', 'src':$alias[name][1]})];
      };

      $('lch').empty(true, true);
      $('le').empty(true, true);
      $('out').empty(true, true);
      for(var i=0; i<cn; i++) {
        cb.add('div', {'class':'block'}, [
          add('div', {'class':'left', 'style':'width:10px', 'innerHTML':i+1+'. '}),
          add('div', {'class':'nofloat'}, [
            add('div', {'class':'m5'}, [add('input', {'type':'text', 'size':'24'})]),
            // Выбор статуса команды
            add('div', null, [
              add('input', {'type':'checkbox', 'class':'chk', 'id':'champ_'+bn+'_'+i}),
              add('label', {'for':'champ_'+bn+'_'+i}, stimg('champ')),
              add('input', {'type':'checkbox', 'class':'chk', 'id':'cup_'+bn+'_'+i}),
              add('label', {'for':'cup_'+bn+'_'+i}, stimg('cup')),
              add('input', {'type':'checkbox', 'class':'chk', 'id':'new_'+bn+'_'+i}),
              add('label', {'for':'new_'+bn+'_'+i}, stimg('new'))
            ])
          ])
        ]);
      }

      // Создаем панельку выбора подсветки зон для мест в турнирной таблице
      for(var i=0,l=nums.length==0 ? cn : getMax(nums); i<l; i++) {
        $('lch').add('input', {'type':'checkbox', 'class':'chk', 'id':'lch_'+(i+1)}).$('click', chkHandler);
        $('lch').add('label', {'for':'lch_'+(i+1), 'style':'padding-right:10px'}, [addtext(i+1)]);
        $('le').add('input', {'type':'checkbox', 'class':'chk', 'id':'le_'+(i+1)}).$('click', chkHandler);
        $('le').add('label', {'for':'le_'+(i+1), 'style':'padding-right:10px'}, [addtext(i+1)]);
        $('out').add('input', {'type':'checkbox', 'class':'chk', 'id':'out_'+(i+1)}).$('click', chkHandler);
        $('out').add('label', {'for':'out_'+(i+1), 'style':'padding-right:10px'}, [addtext(i+1)]);
      }
    };

    $('groups').add('h3', {'innerHTML':'Структура турнира'});
    $('groups').add('div', {'id':'zones', 'class':'m20'}, [
      add('div', {'class':'m5'}, [
        add('input', {'type':'text', 'size':'30', 'value':$alias.lch, 'id':'lch_text'}),
        add('span', {'style':'padding-left:15px', 'id':'lch'})
      ]),
      add('div', {'class':'m5'}, [
        add('input', {'type':'text', 'size':'30', 'value':$alias.le, 'id':'le_text'}),
        add('span', {'style':'padding-left:15px', 'id':'le'})
      ]),
      add('div', {'class':'m5'}, [
        add('input', {'type':'text', 'size':'30', 'value':$alias.out, 'id':'out_text'}),
        add('span', {'style':'padding-left:15px', 'id':'out'})
      ])
    ]);
    $('groups').add('div', {'class':'hr m20', 'style':'clear:both', 'innerHTML':'&nbsp;'});
    for(var i=0; i<num; i++) {
      $('groups').add('div', {'class':'nofloat m20'}, [
        num!=1 ? add('div', {'class':'m10'}, [
          add('b', {'innerHTML':'Группа:'}),
          add('input', {'type':'text', 'size':'2', 'style':'margin-left:7px', 'id':'group_'+i}),
          add('span', {'innerHTML':'&nbsp;&nbsp;c&nbsp;&nbsp;'}),
          add('input', {'type':'text', 'size':'2', 'value':cn, 'class':'commands_nums', 'id':'commands_num_'+(i+1)}).$('keyup', createComs),
          add('span', {'innerHTML':'&nbsp;&nbsp;командами'}),
        ]) : null,
        add('div', {'id':'commands_'+i, 'class':'commands_container'})
      ]);

      createComs(num!=1 ? 'commands_num_'+(i+1) : 'commands_num_0');
      if(i!=num-1) $('groups').add('div', {'class':'hr m20', 'style':'clear:both', 'innerHTML':'&nbsp;'});
    }
  }).$('click', 'groups_add');

  // Смена типов и сортировок таблицы бомбардиров
  (function(e) {
    var type = parseInt((e.target || e.srcElement).value), sorting = parseInt(selOption('b_sorts'));
    createBombers(type, sorting);
  }).$('change', 'b_types');
  (function(e) {
    var type = parseInt(selOption('b_types')), sorting = parseInt((e.target || e.srcElement).value);
    createBombers(type, sorting);
  }).$('change', 'b_sorts');

  // Ввод данных
  inputHandler.$('keyup', 'count_home', 'count_guest', 'count_home_ps', 'count_guest_ps');
  if(objTools.length(data)) inputHandler.$('change', 'com_home', 'com_guest');

  // Включение/выключение серии пенальти
  (function(e) {
    var chk = e.target || e.srcElement, epsc = $('extra_ps_div');
    if(chk.checked) {
      epsc.show();
      try { $('count_home_ps').focus(); } catch(err) {};
    } else epsc.hide();
    inputHandler('count_home_ps');
  }).$('click', 'extra_ps');

  // Отмена ввода новой команды и новой стадии
  (function(e) {
    var inp = e.target || e.srcElement, egi = (inp.id == 'extra_group_inp');
    if(e.keyCode==27) {
      var selector = egi ? inp.previousSibling : inp.previousSibling.firstChild;
      $(selector).show();
      $(inp).hide();
      if(egi) extraHandler('extra');
    }
    if(!egi) inputHandler(e);
  }).$(suilib.client.opera ? 'keypress' : 'keyup', 'com_home_inp', 'com_guest_inp', 'extra_group_inp');

  // Включение/выключение дополнительного матча
  extraHandler.$('click', 'extra');

  // Добавляем матч
  (function(e) {
    var hv = parseInt($('count_home').value, 10), gv = parseInt($('count_guest').value, 10),
        hs = selOption('com_home') == 'add' ? $('com_home_inp').value : selOption('com_home'),
        gs = selOption('com_guest') == 'add' ? $('com_guest_inp').value : selOption('com_guest');
    if($isResults) var mn = selOption('input_tour'), hcb = {}, gcb = {},
                       extra = $('extra').checked, extra_save = $('extra_save').checked, extra_ps = $('extra_ps').checked,
                       extra_group = selOption('extra_group') == 'add' ? $('extra_group_inp').value : selOption('extra_group'),
                       hps = parseInt($('count_home_ps').value, 10), gps = parseInt($('count_guest_ps').value, 10);

    var arr = function(c) { // обёртка для функции getComData
      return getComData(c);
    };

    if(parseInt(mn, 10)>$total[0]) { // защита от меня долбоёба ;-)
      alert('Такого тура для выбранной группы не существует!');
      return false;
    }
    if(extra && (extra_group=='add' || extra_group=='')) { // защита от дурака О_о
      alert('Необходимо ввести названия стадии!');
      return false;
    }
    if(!extra && ((arr(hs)[0]+arr(hs)[1]+arr(hs)[2])>=$total[0] || (arr(gs)[0]+arr(gs)[1]+arr(gs)[2])>=$total[0])) { // защита от второго дурака o_О
      alert('Все матчи одной или обеих команд уже были сыграны!');
      return false;
    }
    if(!extra && arr(hs)[6][mn]) { // защита от третьего дурака O_O
      alert('Извините, но этот матч уже был сыгран: вы можете исправить результат, включив в блоке ввода дополнительный матч!');
      return false;
    }

    // Проверяем заполнены ли все поля ввода новых бомбардиров
    var isBombs = (hv + gv == 0) ? false : true,
        isEmpty = false,
        all = $('bombs_input').filter('li', null, null, true),
        names = [], times = [], pnls = [], autos = [], coms = [];

    if(isBombs) {
      $(all).walkwith(function(el) {
        var childs = $(el).filter('div', null, null, true);
        var name = (childs[0].firstChild.style.display == 'none') ? childs[0].firstChild.nextSibling.value : selOption(childs[0].firstChild),
            time = $isResults ? $(childs[2]).filter('input', null, null, true)[0].value : '1'; // назначаем корректную "пустышку", если сохранение результатов отключено
        if(name=='' || name=='add' || time=='' || isNaN(parseInt(time, 10)) || parseInt(time, 10)<=0) isEmpty = true;
        names.push(name);
        times.push(time);
        pnls.push(childs[$isResults ? 3 : 2].firstChild.checked);
        autos.push($(childs[$isResults ? 3 : 2]).filter('span', null, null, true)[0].style.display == 'none' ? false : true);
        coms.push(selOption($(childs[1]).filter('select', null, null, true)[0]));
      });
      if(isEmpty) { // защита от четвёртого дурака O_О O_О
        alert('Необходимо корректно заполнить все поля в блоке ввода бомбардиров!');
        return false;
      }
    }

    // Удаляем нужный матч вместе с результатами, если добавляется переигровка
    if(extra && !matchType(extra_group)) {
      if(!arr(hs)[6][extra_group]) { // еще защита O_О
        alert('Матч, который Вы хотите изменить, не был сыгран: пожалуйста, воспользуйтесь обычным способом добавления!');
        return false;
      }

      var mtch = arr(hs)[6][extra_group].split('|'), rm = getCount(mtch[1], mtch[2]);

      // Удаляем статистику матча
      if(rm[0]>rm[1]) {
        arr(hs)[0]--; arr(gs)[2]--;
      } else if(rm[0]==rm[1]) {
        arr(hs)[1]--; arr(gs)[1]--;
      } else {
        arr(gs)[0]--; arr(hs)[2]--;
      }
      arr(hs)[3] -= rm[0]; arr(hs)[4] -= rm[1];
      arr(gs)[3] -= rm[1]; arr(gs)[4] -= rm[0];

      // Удаляем статистику бомбардиров
      var deleteInBombs = function(str, com) {
        if(!str) return false;

        var hb = str.split(',');
        for(var i=0,l=hb.length; i<l; i++) {
          var all = hb[i].split('^');
          if(!arr(com)[5][all[0]]) continue;
  
          for(var j=1,k=all.length; j<k; j++) {
            arr(com)[5][all[0]][0]--;
            if(all[j].find('%')) arr(com)[5][all[0]][1]--;
          }
          if(arr(com)[5][all[0]][0]==0) delete arr(com)[5][all[0]];
        }
      };
      deleteInBombs(mtch[1], hs); deleteInBombs(mtch[2], gs);

      // Удаляем результат
      arr(hs)[6][extra_group] = '';
    }

    // Сохраняем победы-ничьи-поражения и разницу мячей
    if(!extra || (extra && !matchType(extra_group))) {
      if(hv>gv) {
        arr(hs)[0]++; arr(gs)[2]++;
      } else if(hv==gv) {
        arr(hs)[1]++; arr(gs)[1]++;
      } else {
        arr(gs)[0]++; arr(hs)[2]++;
      }
      arr(hs)[3] += hv; arr(hs)[4] += gv;
      arr(gs)[3] += gv; arr(gs)[4] += hv;
    }

    if(isBombs) {
      for(var i=0,l=all.length; i<l; i++) {
        // Сохраняем бомбардиров
        var rc = autos[i] ? (coms[i] == hs ? gs : hs) : coms[i];

        if(arr(rc) && (!extra || (extra && extra_save))) {
          if(!arr(rc)[5][names[i]]) arr(rc)[5][names[i]] = [0, 0];
          arr(rc)[5][names[i]][0]++;
          if(pnls[i]) arr(rc)[5][names[i]][1]++;
          if(autos[i]) arr(rc)[5][names[i]][1] = coms[i];
        }

        // Готовим хэш для сохранения результатов
        if($isResults) {
          var hash = rc==hs ? hcb : gcb;
          if(!hash[names[i]]) hash[names[i]] = '';
          hash[names[i]] += '^' + times[i] + (pnls[i] ? '%' : '') + (autos[i] ? '@' : '');
        }
      }
    }

    // Сохраняем результаты
    if($isResults) {
      var harr = [], garr = [];
      for(var i in hcb) harr.push(i + hcb[i]);
      for(var i in gcb) garr.push(i + gcb[i]);

      var str = gs + (harr.length ? ('|' + harr.join(',')) : ((garr.length || extra_ps) ? '|' : '')) + (garr.length ? ('|' + garr.join(',')) : (extra_ps ? '|' : '')) + (extra_ps ? ('|' + hps + ':' + gps) : ''),
          num = false;
      if(extra && matchType(extra_group)) {
        var keys = [];
        for(var i in $extra_names) keys.push(parseInt(i, 10));
        var minV = getMin(keys), maxV = getMax(keys);
        num = $total[1] ? ((isFinite(minV) && minV < 0) ? (minV - 1) : -1) : ((isFinite(maxV) && maxV > $total[0]) ? (maxV + 1) : $total[0] + 1);
        var name = $extra_names[extra_group] ? extra_group + '|' + $extra_names[extra_group] : num + '|' + extra_group;

        if(!data[$key].extra) data[$key].extra = {};
        if(!data[$key].extra[name]) data[$key].extra[name] = [];
        data[$key].extra[name].push(hs + '|' + str);
      } else {
        num = extra && !matchType(extra_group) ? extra_group : mn;
        arr(hs)[6][num] = str;
      }
      $url.tour = num;
    }

    // Сохраняем время редактирования и перегружаем страницу
    data[$key].service.edited = currentTime();
    loadData();
  }).$('click', 'match_add');

  // Выводим хэш данных для ручного сохранения
  (function(e) {
    var ie = suilib.client.msie,
        szs = suilib.screensizes(),
        ts = function() {
               $('data').select();
             },
        dr = function() {
               document.location.reload(true);
             },
        dc = function(e) {
               if((e.type=='keypress' && e.keyCode==27) || e.type=='click') {
                 $('popup').hide();
                 $('saver').hide();
               }
             }; 
    if(!document.getElementById('saver')) $(suilib.body).add('div', {'id':'saver', 'style':'position:' + (ie ? 'absolute' : 'fixed') + ';top:0;left:0;z-index:9998;background:#000000;width:' + (ie ? szs[2]+'px' : '100%') + ';height:' + (ie ? szs[3]+'px' : '100%')}); else $('saver').show();
    if(!ie) $('saver').setstyle('opacity:0');
    $('saver').setstyle('opacity:20');
    $('popup').setstyle('top:' + Math.ceil(szs[1]/2 - 170) + 'px;left:' + Math.ceil(szs[0]/2 - 350) + 'px');
    $('popup').show(.4, 'fade');
    $('data').value = objTools.print(data);
    setTimeout(ts, 600);

    // Снимаем события, если они уже были, и снова навешиваем
    ts.$$('click', 'data');
    dr.$$('click', 'data_refresh');
    dc.$$('click', 'data_close', 'saver').$('keypress', document);
    ts.$('click', 'data');
    dr.$('click', 'data_refresh');
    dc.$('click', 'data_close', 'saver').$('keypress', document);
  }).$('click', 'data_save');
});


/* Все данные (начало вставки) */
var data = {};
/* Все данные (конец вставки) */
//]]>
</script>

</body>
</html>